{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EUC Developer","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque nec maximus ex. Sed consequat, nulla quis malesuada dapibus, elit metus vehicula erat, ut egestas tellus eros at risus. In hac habitasse platea dictumst. Phasellus id lacus pulvinar erat consequat pretium. Morbi malesuada arcu mauris Nam vel justo sem. Nam placerat purus non varius luctus. Integer pretium leo in sem rhoncus, quis gravida orci mollis. Proin id aliquam est. Vivamus in nunc ac metus tristique pellentesque. Suspendisse viverra urna in accumsan aliquet.</p> <p>Donec volutpat, elit ac volutpat laoreet, turpis dolor semper nibh, et dictum massa ex pulvinar elit. Curabitur commodo sit amet dolor sed mattis. Etiam tempor odio eu nisi gravida cursus. Maecenas ante enim, fermentum sit amet molestie nec, mollis ac libero. Vivamus sagittis suscipit eros ut luctus.</p> <p>Nunc vehicula sagittis condimentum. Cras facilisis bibendum lorem et feugiat. In auctor accumsan ligula, at consectetur erat commodo quis. Morbi ac nunc pharetra, pellentesque risus in, consectetur urna. Nulla id enim facilisis arcu tincidunt pulvinar. Vestibulum laoreet risus scelerisque porta congue. In velit purus, dictum quis neque nec, molestie viverra risus. Nam pellentesque tellus id elit ultricies, vel finibus erat cursus.</p>"},{"location":"#featured-resources-for-developers","title":"Featured Resources for Developers","text":"<ul> <li> <p> APIs </p> <p>Build on VMware products, manage &amp; automate your infrastructure</p> </li> <li> <p> Sample Exchange </p> <p>Find and share code samples for VMware APIs, SDKs and CLIs</p> </li> <li> <p> PowerCLI </p> <p>Use PowerShell to manage &amp; automate VMware infrastructure</p> </li> <li> <p> Open Source </p> <p>View open source projects and initiatives from our community</p> </li> <li> <p> Tools </p> <p>Find utilities and tools for OVF packages, Aria (vRealize) file management, remote management of ESXi hosts, automated log management and more.</p> </li> <li> <p> Tanzu Developer Center </p> <p>Visit the Tanzu Developer Center for guides, code samples, workshops, and videos, all to help you learn the modern application development patterns you need to run apps using containers and Kubernetes, build microservices with Spring, and more!</p> </li> <li> <p> Developer Training </p> <p>Visit Pathfinder to learn how VMware solutions are solving business problems for top enterprises. Evaluate by experiencing a day in the life of a VMware IT admin, employee or executive. Validate best methods to adopt these technologies.</p> </li> <li> <p> VMware Marketplace </p> <p>Explore over 2000 services and utilities on the VMware Marketplace to accelerate your modern application development. You can choose ISV solutions based on use cases, certification/validation, form factor, product compatibility and pricing.</p> </li> </ul>"},{"location":"about/","title":"About","text":""},{"location":"about/#proposal-summary","title":"Proposal Summary","text":"<p>There is an opportunity to re-think how we create, manage, and deliver our public facing documentation as we separate EUC from VMware as part of the EUC divestment.</p> <p>We will need to re-create or implement alternative systems for all of our public facing documentation, including the Developer Portal.</p> <p>Companies, such as Microsoft and GitLab, have migrated to a documentation-as-code approach enabling customers to contribute to the public facing documentation by raising documentation issues, proposing corrections, and even directly contributing documentation through pull requests.</p> <p>This document proposes we consider adopting a documentation-as-code approach for our public facing documentation, especially the Developer Portal. Considering, EUC is migrating to GitHub for its Source code management (SCM), we propose using GitHub's Documentation-as-Code offering called GitHub Pages.</p> <p>A rough proof-of-concept has been created using GitHub, GitHub Pages, and MkDocs - it is available here:\u00a0EUC Developer Portal PoC</p> Teams using Docs-as-Code approach <p>A number of VMware teams have been using this approach for the public documentation - see Appendix A for examples.</p>"},{"location":"about/#requirements","title":"Requirements","text":"<ul> <li>Hosting<ul> <li>Actual documentation</li> <li>Possibly, the source material for documentation</li> <li>Global i.e. host in multiple regions to performant and relevant documentation for different regions</li> </ul> </li> <li>Granular Access Controls<ul> <li>With the intention of allowing different teams to own different parts of the documentation<ul> <li>e.g. Sales/Marketing/etc own part of content most relevant to their region while still having global content/styling/etc</li> <li>e.g. Development teams own the documentation/content related to their APIs/SDKs</li> </ul> </li> <li>Providing consistent process and oversight to ensure only reviewed and approved content is published</li> </ul> </li> <li>Customisation<ul> <li>Branding</li> <li>Styling<ul> <li>Support various media types within the site(s)</li> <li>Support various device format (i.e. phones, tablets, laptop computers)</li> </ul> </li> <li>Support different content/languages/etc for different regions</li> </ul> </li> <li>Search and grouping of information</li> <li>Search by date or tag or category</li> <li>List all pages/content with a specific tags</li> <li>List all pages/content in a specific category</li> <li>Integrations<ul> <li>EUC videos hosted via YouTube</li> <li>Embedding of content/posts from Facebook/Instagram, X/Twitter, etc</li> <li>Embedding of OpenAPI Specifications as part REST API or SDK documentation</li> <li>Embedding of typical diagrams used to describe design and function of APIs/SDKs/etc<ul> <li>E.g. Architecture block diagrams</li> <li>E.g. Sequence diagrams</li> <li>E.g. Class and Entity diagrams</li> <li>E.g. Swagger UI rendering of OpenAPI specifications</li> </ul> </li> </ul> </li> <li>Globalisation/Localisation/Multi-language support/etc</li> <li>Versioning support to align documentation with specific product/API/SDK version documented</li> <li>Ability for customers to provide feedback, raise documentation issues, and, hopefully, contribute to the public facing documentation.</li> </ul>"},{"location":"about/#current-approach-and-structure","title":"Current Approach and Structure","text":"<p>The current approach is to leverage the same systems that VMware provided and to find appropriate section of their documentation where our EUC documentation could be included.</p> <p>The current structure of the Developer Portal under developer.vmware.com is:</p> <pre><code>graph TD\n    A(developer.vmmware.com)\n    A --&gt; B(Products)\n    A --&gt; D(APIs)\n    A --&gt; E(PowerCLI)\n    A --&gt; F(Code Samples)\n    A --&gt; G(SDKs)\n    A --&gt; H(\"{code}\")</code></pre> <p>Assuming, we have access to the source material for the EUC content within developer.vmware.com, this structure could easily be translated to a new <code>euc.com</code> domain.</p> <pre><code>graph TD\n    A(developer.euc.com)\n    A --&gt; B(Products)\n    A --&gt; D(APIs)\n    A --&gt; E(PowerCLI)\n    A --&gt; F(Code Samples)\n    A --&gt; G(SDKs)\n    A --&gt; H(\"{code}\")</code></pre> <p>The issue is we will need to stand up documentation systems that match those used while part of VMware. This will incur additional costs and we may not want to continue using these systems as a standalone company.</p>"},{"location":"about/#an-alternative-approach","title":"An Alternative Approach","text":"<p>EUC is migrating to GitHub for its Source code management (SCM). GitHub's Documentation-as-Code offering is GitHub Pages and it is included in most GitHub pricing plans. GitHub Pages hosts web sites for the organisations, teams, and open source projects that use GitHub to manage their source code. Organisations/Teams/Developers simply put the HTML/JavaScript/CSS for the website in a Git branch called <code>gh-pages</code> and GitHub will publish it to <code>github.io</code> (or a custom domain, if configured). See Appendix B </p> <p>GitHub Pages supports a number of static (web)site generators, such as (but not limited to) Jekyll, Hugo, and MkDocs, and more. These tools allow Organisations/Teams/Developers to include their documentation in Markdown (or similar format) in the same GitHub repository as their source code and, as part of their CI/CD pipeline (via GitHub Actions), run the static site generator over the Markdown files to produce HTML/JavaScript/CSS for the website, and merge it into the <code>gh-pages</code> branch from where GitHub will publish it.</p>"},{"location":"about/#all-public-documentation","title":"All Public Documentation","text":"<p>If we were considering using a documentation-as-code approach for all of our public documentation and that documentation had the following structure:</p> <pre><code>graph TD\n    A(euc.github.io)\n    A --&gt; B(/products)\n    A --&gt; C(/developer)\n    A --&gt; D(/blogs)\n    A --&gt; E(. . .)</code></pre> <p>We would have a corresponding GitHub repository structure:</p> <pre><code>graph TD\n    A(github.com/euc/euc.github.io)\n    A --&gt; B(github.com/euc/products)\n    A --&gt; C(github.com/euc/developer)\n    A --&gt; D(github.com/euc/blogs)\n    A --&gt; E(. . .)</code></pre> <p>Ownership of the various sections of the public documentation, such as the <code>/products</code> area, would be granted via GitHub's access controls to the appropriate team, such as the  <code>Sales and Marketing</code> team, that has been configured within GitHub. Similarly, the Developer Portal section of the public documentation (i.e. <code>/developer</code>), would be granted to the <code>Engineering</code> team configured within GitHub. The teams configured within GitHub are synchronised with internal EUC groups via integration with our Identity Provider (WS1 Access?).</p> <p>Further segmentation of the public documentation is possible by having multiple GitHub repositories and leveraging the ability of static (web)site generators to set a base URL from which all internal (to generated website) links are built. As an example, if we want to segment the /<code>products</code> section of the public documentation to have sections for each product and have each product team able to create/edit/etc content for their product but no other product, we would have the following structure for the /<code>products</code> section of the public documentation:</p> <pre><code>graph TD\n    B(/products)\n    B --&gt; F(UEM)\n    B --&gt; G(Horizon)\n    B --&gt; H(Workspace ONE)\n    B --&gt; I(. . .)</code></pre> <p>This would map to following GitHub repository structure:</p> <pre><code>graph TD\n    B(github.com/euc/products)\n    B --&gt; F(github.com/euc/UEM)\n    B --&gt; G(github.com/euc/Horizon)\n    B --&gt; H(github.com/euc/WorkspaceONE)\n    B --&gt; I(. . .)</code></pre> <p>In the above example:</p> <ul> <li>the Corporate Sales and Marketing team could own the <code>github.com/euc/products</code> repository</li> <li>UEM / Horizon / Workspace ONE product Sales and Marketing teams could own their respective product-based repositories. </li> </ul> <p>This allows for Corporate Sales and Marketing team to set the overall messaging/branding (incl. styles, fonts, colours, etc) and the product-based teams inherit from corporate or, if the need arises, to override with their own messaging/branding.</p> Info <p>As an aside, GitHub supports are very flat hierarchy for Git repositories, namely <code>github.com/&lt;org/team/user&gt;/&lt;repository&gt;</code> where <code>&lt;org/team/user&gt;</code> is the organisation, team, or user name and <code>&lt;repository&gt;</code> is the name of the Git repository. </p> <p>Some systems, like GitLab, support the concept of groups and sub-groups which would allow for a direct one-to-one mapping. e.g.</p> <pre><code>graph TD\n    B(gitlab.com/euc/products)\n    B --&gt; F(gitlab.com/euc/products/UEM)\n    B --&gt; G(gitlab.com/euc/products/Horizon)\n    B --&gt; H(gitlab.com/euc/products/WorkspaceONE)\n    B --&gt; I(. . .)</code></pre>"},{"location":"about/#developer-specific-documentation","title":"Developer-specific Documentation","text":"<p>The current structure of the Developer Portal under developer.vmware.com is:</p> <pre><code>graph TD\n    A(developer.vmmware.com)\n    A --&gt; B(Products)\n    A --&gt; D(APIs)\n    A --&gt; E(PowerCLI)\n    A --&gt; F(Code Samples)\n    A --&gt; G(SDKs)\n    A --&gt; H(\"{code}\")</code></pre> <p>While it can be made to work, this current structure doesn't allow for easy or clear mapping of each section of the documentation to a single GitHub repository whose content owned by single development team.</p> <p>However, if the developer section was (re)structured by product e.g.:</p> <pre><code>graph TD\n    C(/developer)\n    C --&gt; I(UEM)\n    C --&gt; J(Horizon)\n    C --&gt; K(Workspace ONE)\n    C --&gt; L(PowerCLI)\n    C --&gt; M(. . .)</code></pre> <p>We would have a clear/clean mapping of section of the developer portal to GitHub repository which is owned by the team who builds the component/API/SDKs documented.</p> <pre><code>graph TD\n    B(github.com/euc/developer)\n    B --&gt; F(github.com/euc/developer/UEM)\n    B --&gt; G(github.com/euc/developer/Horizon)\n    B --&gt; H(github.com/euc/developer/WorkspaceONE)\n    B --&gt; I(. . .)</code></pre> <p>Again, as with the <code>/products</code> example above, the <code>/developer</code> section of the public documentation can be further segmented and ownership delegated to the teams who are working daily on the product that is being documented.</p> <pre><code>graph TD\n    C(/developer)\n    C --&gt; I(UEM)\n    C --&gt; J(Horizon)\n    C --&gt; M(. . .)\n    I --&gt; N(UEM SDK)\n    I --&gt; O(UEM REST API)\n    I --&gt; P(UEM PowerShell)\n    J --&gt; Q(Horizon SDK)\n    J --&gt; R(Horizon REST API)\n    J --&gt; S(Horizon PowerShell)\n    M --&gt; W(. . .)\n    M --&gt; X(. . .)</code></pre> <p>This would map to following GitHub repository structure:</p> <pre><code>graph TD\n    A(github.com/euc/developer)\n    A --&gt; B(github.com/euc/uem)\n    A --&gt; C(github.com/euc/horizon)\n    B --&gt; D(github.com/euc/uem-sdk)\n    B --&gt; E(github.com/euc/uem-rest-api)\n    B --&gt; F(github.com/euc/uem-powershell)\n    C --&gt; G(github.com/euc/horizon-sdk)\n    C --&gt; H(github.com/euc/horizon-rest-api)\n    C --&gt; I(github.com/euc/horizon-powershell)\n    A --&gt; J(. . .)\n    J --&gt; K(. . .)\n    J --&gt; L(. . .)</code></pre> <p>In the above example:</p> <ul> <li>the Engineering and/or Technical Market team could own the <code>euc.github.io/developer</code> section of the documentation and the corresponding <code>github.com/euc/developer</code> repository</li> <li>the UEM team could own the <code>euc.github.io/developer/uem</code> section of the documentation and the corresponding <code>github.com/euc/uem</code> and <code>github.com/euc/uem-*</code> repositories</li> <li>the Horizon team could own the <code>euc.github.io/developer/horizon</code> section of the documentation and the corresponding <code>github.com/euc/horizon</code> and <code>github.com/euc/horizon-*</code> repositories </li> </ul> <p>This allows for Engineering and/or Technical Market teams to set the overall developer messaging/branding (incl. styles, fonts, colours, etc) and the product-based teams inherit or, if the need arises, to override with their own messaging/branding.</p>"},{"location":"about/#api-documentation","title":"API Documentation","text":""},{"location":"about/#powershell-documentation","title":"PowerShell Documentation","text":""},{"location":"about/#blogs","title":"Blogs","text":"<p>Blogs could be handled in a very similar way to the other sections of the public documentation i.e. the blogs section could be structured like this:</p> <pre><code>graph TD\n    A(euc.github.io)\n    A --&gt; D(/blogs)\n    D --&gt; M(/UEM)\n    D --&gt; N(/Horizon)\n    D --&gt; O(/WorkspaceONE)\n    D --&gt; P(/PowerCLI)\n    D --&gt; Q(. . .)</code></pre> <p>However, aggregating into a number of different channels or feeds as well as a single all blogs channel would become cumbersome and difficult to maintain very quickly.</p> <p>This proposal recommends having a single blog repository and use <code>tags</code> and <code>categories</code> to group and filter the blogs posts. The static (web)site generators provide the concept of list pages where they generate pages listing all content with a particular <code>tag</code> or <code>category</code>.</p> <p>For example, you can have a <code>UEM Developer Blog</code> list page that contains all blog posts with the <code>uem</code>, <code>uem-sdk</code>, <code>uem-rest-api</code>, or <code>uem-powershell</code> tags/categories.</p>"},{"location":"about/#appendix-a","title":"Appendix A","text":"<p>A number of VMware teams have been using this approach for the public documentation.</p> <p>The Tanzu team ran the Tanzu Developer Portal from github.com/vmware-tanzu/tanzu-dev-portal. The Tanzu Developer Portal contained information covering:</p> <ul> <li>Engaging with Tanzu for consulting engagements</li> <li>Tutorials/guides/process documentation for Agile software development (used as part of consulting as well)</li> <li>Episode summaries and embedded content hosted on YouTube (e.g. TanzuTV, TGIK, etc)</li> <li>Blogs from member of the Tanzu team (incl. Developer advocates, etc)</li> </ul> <p>The VMware Cloud Foundation team are using this approach for:</p> <ul> <li>PowerShell Module for VMware Validated Solutions  </li> <li>PowerShell Module for VMware Cloud Foundation  </li> <li>PowerShell Module for VMware Cloud Foundation Reporting  </li> <li>PowerShell Module for VMware Cloud Foundation Password Management  </li> <li>PowerShell Module for VMware Cloud Foundation Certificate Management  </li> </ul>"},{"location":"about/#appendix-b","title":"Appendix B","text":"<p>The following table shows how to translate your organisation/team/user repository structure to GitHub Pages URL:</p> Repo Name Repo URL GitHub Pages URL <code>&lt;username&gt;.github.io</code> <code>https://github.com/&lt;username&gt;.github.io</code> <code>http(s)://&lt;username&gt;.github.io</code> <code>&lt;organization&gt;.github.io</code> <code>https://github.com/&lt;organization&gt;.github.io</code> <code>http(s)://&lt;organization&gt;.github.io</code> <code>&lt;organization-user&gt;.github.io</code> <code>https://github.com/&lt;organization-user&gt;.github.io</code> <code>http(s)://&lt;organization-user&gt;.github.io</code> <code>&lt;username&gt;/&lt;repositiory&gt;</code> <code>https://github.com/&lt;username&gt;/&lt;repositiory&gt;</code> <code>http(s)://&lt;username&gt;.github.io/&lt;repository&gt;</code> <code>&lt;organization&gt;/&lt;repositiory&gt;</code> <code>https://github.com/&lt;organization&gt;/&lt;repositiory&gt;</code> <code>http(s)://&lt;organization&gt;.github.io/&lt;repository&gt;</code>"},{"location":"about/#references","title":"References","text":"<ul> <li>About GitHub Pages - GitHub Docs</li> <li>Changing the visibility of your GitHub Pages site - GitHub Enterprise Cloud Docs</li> <li>About custom domains and GitHub Pages - GitHub Docs</li> </ul>"},{"location":"about/#appendix-c","title":"Appendix C","text":"<p>Everything in one diagram:</p> <pre><code>graph TD\n\n    A(euc.github.io)\n\n    A --&gt; B(/products)\n    A --&gt; C(/developer)\n    A --&gt; D(/blogs)\n    A --&gt; E(. . .)\n\n    B --&gt; F(UEM)\n    B --&gt; G(Horizon)\n    B --&gt; H(Workspace ONE)\n\n    C --&gt; I(UEM)\n    C --&gt; J(Horizon)\n    C --&gt; K(Workspace ONE)\n\n    E --&gt; W(. . .)\n    E --&gt; X(. . .)\n\n    I --&gt; N(UEM SDK)\n    I --&gt; O(UEM REST API)\n    I --&gt; P(UEM PowerShell)\n\n    J --&gt; Q(Horizon SDK)\n    J --&gt; R(Horizon REST API)\n    J --&gt; S(Horizon PowerShell)\n\n    K --&gt; T(WS1 SDK)\n    K --&gt; U(WS1 REST API)\n    K --&gt; V(WS1 PowerShell)</code></pre>"},{"location":"about/#appendix-d","title":"Appendix D","text":"<p>Alternative function-based structure in one diagram:</p> <pre><code>graph TD\n    A(euc.github.io)\n\n    A --&gt; B(/products)\n    A --&gt; C(/developer)\n    A --&gt; D(/blogs)\n    A --&gt; E(. . .)\n\n    B --&gt; F(UEM)\n    B --&gt; G(Horizon)\n    B --&gt; H(Workspace ONE)\n    B --&gt; I(. . .)\n\n    C --&gt; J(SDKs)\n    C --&gt; K(REST APIs)\n    C --&gt; L(PowerShell)\n    C --&gt; M(Samples)\n\n    J --&gt; N(UEM)\n    J --&gt; O(Horizon)\n    J --&gt; P(Workspace ONE)\n    J --&gt; Q(. . .)\n\n    K --&gt; R(UEM)\n    K --&gt; S(Horizon)\n    K --&gt; T(Workspace ONE)\n    K --&gt; U(. . .)\n\n    L --&gt; V(UEM)\n    L --&gt; W(Horizon)\n    L --&gt; X(Workspace ONE)\n    L --&gt; Y(. . .)\n\n    M --&gt; Z(UEM)\n    M --&gt; AA(Horizon)\n    M --&gt; AB(Workspace ONE)\n    M --&gt; AC(. . .)</code></pre>"},{"location":"api/","title":"Workspace ONE APIs","text":"<p>Under this part of the site we have a collection of API docs for EUC products.</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque nec maximus ex. Sed consequat, nulla quis malesuada dapibus, elit metus vehicula erat, ut egestas tellus eros at risus. In hac habitasse platea dictumst. Phasellus id lacus pulvinar erat consequat pretium. Morbi malesuada arcu mauris Nam vel justo sem. Nam placerat purus non varius luctus. Integer pretium leo in sem rhoncus, quis gravida orci mollis. Proin id aliquam est. Vivamus in nunc ac metus tristique pellentesque. Suspendisse viverra urna in accumsan aliquet.</p> <p>Donec volutpat, elit ac volutpat laoreet, turpis dolor semper nibh, et dictum massa ex pulvinar elit. Curabitur commodo sit amet dolor sed mattis. Etiam tempor odio eu nisi gravida cursus. Maecenas ante enim, fermentum sit amet molestie nec, mollis ac libero. Vivamus sagittis suscipit eros ut luctus.</p> <p>Nunc vehicula sagittis condimentum. Cras facilisis bibendum lorem et feugiat. In auctor accumsan ligula, at consectetur erat commodo quis. Morbi ac nunc pharetra, pellentesque risus in, consectetur urna. Nulla id enim facilisis arcu tincidunt pulvinar. Vestibulum laoreet risus scelerisque porta congue. In velit purus, dictum quis neque nec, molestie viverra risus. Nam pellentesque tellus id elit ultricies, vel finibus erat cursus.</p>"},{"location":"api/api-guidelines/","title":"VMware REST API Standard Practices","text":"<p>September 2021</p> <p>Version 2.1</p>"},{"location":"api/api-guidelines/#overview","title":"Overview","text":"<p>There have been many discussions and efforts at VMware over the years around how to bring the appropriate level of consistency to our APIs as to allow customers to learn APIs faster and also provide consistent documentation and tooling support across the board. This lack of consistency has been a long-standing problem for us, and one that is complicated by VMware's vastly diverse portfolio and underlying technologies.</p> <p>For example a Java developer willing to work with vRA, vCenter and NSX together as of this moment may experience difficulties as SDKs may not be readily available in Java for all products, even if SDKs are available they are very likely to use conflicting versions of 3rd party libraries and the design patterns behind the different products are different. There is also a conflicting point of view that enforcing consistency top down will stifle innovation and prevent use of the latest technologies in VMware's products.</p> <p>This specification aims to strike a balance between these competing priorities by keeping consistency goals in areas important for our customers priorities, while giving sufficient freedom to individual teams to adopt innovative approaches. This specification will also defer to superseding, enterprise-wide standards where VMware has warranted in very specific areas that such requirements exist.</p> <ul> <li>Align the look and feel of APIs</li> <li>Provide consistent set of tooling and documentation across VMware APIs</li> <li>Refer to superseding standards as appropriate</li> </ul> <p>To support these goals the current specification lists requirements and expectations in 6 critical areas:</p> <ul> <li>Request and Response Types</li> <li>Message Payload</li> <li>API Errors</li> <li>API Documentation</li> <li>API Evolution</li> <li>API Deprecation and Removal</li> </ul> <p>It is not the goal of this document to drive architectural consistency at VMware. This document is aimed to provide guidance for designing the REST API - the protocol they use, the encoding of messages and structuring access patterns. It is understandable that some requirements here may have bearing to product design and architecture. In those cases the specification will try to provide sufficient room for product architects to make choice for their product.</p>"},{"location":"api/api-guidelines/#guiding-principles","title":"Guiding Principles","text":"<p>The document discusses a number of areas and while we try to make it unambiguous it is possible that the guidance is lacking sufficient detail to make design and implementation choice. We want to thus lay out some guiding principles that engineers can use:</p> <ul> <li>Favor local consistency over global consistency \u2014 when faced with a violation of requirement it is more important to preserve consistency with adjacent APIs in the same component to minimize the learning barrier for end users. On a similar note, when a major change to the API is undertaken the thinking should be to provide unification within the family of VMware APIs as to reduce the friction for the new API that will be released.</li> </ul>"},{"location":"api/api-guidelines/#typographical-conventions","title":"Typographical conventions","text":"<p>The remainder of the document presents requirements towards VMware REST APIs. The text is split in two categories \u2014 normative statements and notes. Normative statements represent requirements towards product APIs. Notes aim to clarify the normative statements by presenting examples, background information, opinions of engineers, references to other specifications etc. Normative statements are represented as information boxes. Notes use all other formats in the document. Example normative statement</p> <p>Normative Statement</p> <p>Within normative statements the conventions of RFC 2119 are used. These define the meaning of MAY, SHOULD, SHOULD NOT, MUST and MUST NOT.</p>"},{"location":"api/api-guidelines/#related-work","title":"Related Work","text":"<ul> <li>NSX-T APIs: Developer Guides &amp; Standards</li> <li>CMBU API Standardization</li> <li>VAPI Best Practices &amp; VMODL2 Documentation Guidelines</li> <li>vCloud Director \u2014 API development guide</li> </ul>"},{"location":"api/api-guidelines/#3rd-party","title":"3rd party","text":"<ul> <li>OpenAPI 3.0, legacy v.2.0</li> <li>Microsoft REST API Guidelines</li> <li>Google API Design Guide</li> <li>OpenStack Nova Compute API reference</li> <li>AWS documentation index</li> </ul>"},{"location":"api/api-guidelines/#request-and-response-types","title":"Request and Response Types","text":"<p>This chapter sets out the basic requirements towards the request/response exchange between REST client and a service:</p> <p>RR-1: All requests to the REST API MUST follow HTTP 1.1 specification</p> <p>HTTP 1.1. protocol is defined in RFC 7230, RFC 7231, RFC 7232, RFC 7233, RFC 7234 and RFC 7235</p> <p>HTTP protocol is in the heart of the internet and thus all REST APIs are expected to use it. The HTTP protocol specifies a lot of semantics around requests which help standardized clients to operate the API. It is thus expected that API authors are familiar with the HTTP specification and use it appropriately. Key parts of the HTTP specifications relevant to APIs are HTTP verb semantics, response status codes, standard headers, authentication mechanisms, safe, idempotent and cache-able methods.</p> <p>The remainder of this specification defines constraints on top of the HTTP protocol to make it easier for modeling APIs. No exhaustive effort shall be made in this document to reiterate concepts of HTTP described in relevant RFC documents.</p> <p>This specification is aimed at REST APIs that form the management path of our API surface. There may be other APIs that work with binary data and are not subject to this specification. Example of such APIs may include: file transfer, screen shots, push notifications, south bound driver interfaces, console access etc.</p> <p>RR-2: APIs MUST be able to consume and produce JSON (application/json) RFC 8259 - The JavaScript Object Notation (JSON) Data Interchange Format unless they deal with file or stream data</p> <p>JSON is the de-facto standard for REST API message format as of 2016. It is beneficial to standardize around this syntax and enable common serialization infrastructure.</p> <p>This rule applies to all current JSON based REST APIs and future APIs. There is a set of legacy XML APIs which we hope will support JSON as the respective products evolve. There is realization that transition will take time and for some products that are nearing end of life the transition may not happen.</p> <p>There are APIs that transfer files contents to or from client. Those use cases are covered in the File Transfers chapter. Such APIs need to consume or produce binary data e.g. obtain screen shot of a virtual machine. Those APIs may consume or produce other MIME types that are more appropriate to their use cases e.g. <code>GET /vm/{vm id}/screen-shot</code> may return image/jpeg</p> <p>RR-3: All API functionality MUST be accessible using single request and response pattern (i.e. clients MUST not be required to use streaming, web sockets etc.)</p> <p>It is a common assumption in the existing REST tooling that an API interaction is defined in terms of a single request and single associated response conducted in the same HTTP request. While new standards like web sockets and comet provide utility in specific use cases they enable communication patterns that many off the shelf tools currently do not support. It is thus required to provide the full functionality of the API over simple request/response interface. It is permitted to provide alternate forms of communication as needed.</p> <p>RR-4: API operations MUST be uniquely identified through HTTP verb and URI combination</p> <p>In REST APIs users interact with resources identified by URI and use standard verbs to specify the operation on the resource e.g. HTTP GET on resource URI to retrieve the representation and HTTP PUT/PATCH to update etc. HTTP headers such as Content-type and Accept may be used to select among alternative resource representations e.g. XML/JSON rendering of a resource. It goes against this basic principle to encode API operations in the message header or body (REST APIs must be hypertext driven, R. Fielding, 2008). Encoding operation name in the message body makes the protocol opaque to the HTTP infrastructure and prevents potential benefits like caching and operation through proxies.</p> <p>This requirement will allow us to use off the shelf REST tooling for invoking, serving and documenting APIs. Examples of such tooling include RAML, Swagger, Spring MVC, Apache CXF. Protocols such as XML RPC or SOAP do not fit this requirement as the operations are identified in the message body and require further interpretation of the message body to determine how to handle the request.</p>"},{"location":"api/api-guidelines/#security-requirements","title":"Security requirements","text":"<p>REST APIs may be utilized by different types of clients in variety of environments. These pose various types of threads towards the security of the APIs. A simple set of rules in this chapter aims to provide guidance to API authors on how to avoid common pitfalls that may be detrimental to their service or its clients.</p> <p>RR-5: Encryption MUST be used for communication that is not confined to the loopback interface.</p> <p>All communication to APIs must be conducted over secure channels using approved algorithms. This prevents unauthorized access to security tokens and/or API payload data.</p> <p>Use of unencrypted channels is acceptable for local loopback communication as to minimize the cost of communication. For example unencrypted local loopback channel may be used to communicate to sidecar proxy that is off loading TLS from service implementations.</p> <p>RR-6: API SHOULD NOT return sensitive data like secrets/passwords</p> <p>APIs that need to manage client secrets MUST only accept secrets as inputs and not return them as outputs. Returning passwords may lead to undesired leakage of information.</p> <p>This risk is often seen in APIs for configuration of remote connections.</p> <p>It is feasible to return secrets and passwords when those are generated or owned by given API and/or used for integration purposes. For example the OAuth 2 API returns access and refresh tokens as part of the authentication workflow. See RFC 6570 Section 4. Example Access Token Response</p> <p>RR-7: APIs MUST be hardened against well-known attacks</p> <p>Interpreting inputs from the network should be done with extreme caution. A common vector for attack on APIs is to exploit various deserialization weaknesses. Those include overflowing input buffers, flooding a service with requests, XML expansion and code execution attacks. As an API author make sure to choose mature communication and deserialization libraries and address known risks with the chosen deserialization approach.</p> <p>Examples of common problems to check include:</p> <ul> <li>Make sure that appropriate request size filters are applied to prevent memory pressure due to oversized API requests.</li> <li>When using XML, make sure to disable various XML expansion mechanisms.</li> <li>Make sure that deserialization to objects in a language runtime cannot be used for arbitrary code execution by invoking vulnerable methods or instantiating classes that are not part of the API surface.</li> <li>Use rate and concurrent request limits that guarantee the health of an API endpoint</li> </ul> <p>RR-8: API access SHOULD be properly authenticated</p> <p>API calls should require authentication. Exception to this rule are APIs that allow a client to discover the capabilities of an API endpoint. For example API to retrieve API release number may be open to public unauthenticated access.</p> <p>RR-9: APIs SHOULD use standard HTTP headers for authentication</p> <p>Authentication tokens should be transferred using standard compliant HTTP headers to enable interoperability. See RFC 7235 Section 4.2. Authorization</p> <p>RR-10: API Authentication MUST NOT use cookies</p> <p>APIs must not use cookies to hold credentials as cookies are automatically sent with the request by browsers when a cross origin request is made. Cookies must not be used to hold session keys. If this can't be avoided, sufficient anti-CSRF measures should be taken. See the Cross-Site Request Forgery Prevention Cheat Sheet.</p> <p>RR-11: CORS support SHOULD be restricted</p> <p>CORS should be avoided. In some cases there are overriding business requirements that will necessitate the use of CORS. In those cases CORS may only be used with appropriate restrictions including:</p> <ul> <li>allowed headers</li> <li>allowed methods</li> <li>allowed origin if possible</li> </ul> <p>Avoid sending credentials when using CORS.</p> <p>RR-12: APIs MUST specify <code>content-type</code> header in responses when response body is present.</p> <p><code>application/json</code> with UTF-8 character encoding should be used and properly manifested in API responses. See RFC 8259 Section 8.1. Character Encoding, RFC 8259 Section 11. IANA Considerations, RFC 7231 Section 3.1.1.5. Content-Type</p> <p>RR-13: APIs SHOULD NOT accept sensitive data in query parameters in URI</p> <p>Query parameters may be accessible to rouge scripts or visible in the browser window and must not be used to transfer sensitive or secretive data. URIs including query parameters are often cached, persisted and included in application logs.</p> <p>There are rare exceptions to this rule when short-lived tokens need to be sent using URI. For example in the OAuth 2 specification the authorization code grant workflow uses query parameter. See RFC 6749 Section 4.1.2 Authorization Response. Clients sending sensitive data in the URI should send <code>cache-control</code> header with <code>no-store</code> option and server 2xx responses are to include <code>cache-control</code> with <code>private</code> option. (from RFC 6750 Section 2.3).</p>"},{"location":"api/api-guidelines/#design-for-robust-operation-in-distributed-systems","title":"Design for robust operation in distributed systems","text":"<p>Product APIs are used by customers, second parties, and for integration between VMware products; and thus the actual completion of an API request often involves multiple services. For this reason APIs should be designed with distributed execution in mind. API designers should at minimum consider the following factors in this regard:</p> <p>RR-14: API responses SHOULD be bounded in size</p> <p>API servers and clients should be able to set some expectations for the amount of resources needed to handle API calls. This problem specifically manifests with list and query functionality whose response size may grow substantially in large environments. Clients should be able to specify page size in a list/query request. Further, servers are free to reject the request or respond with reduced result sets to preserve server stability.</p> <p>For certain lists like SCSI devices where list size has implicit size limit it may not be necessary to implement complex pagination interface. This applies as long as the maximum possible size for the list is manageable.</p> <p>Notable exceptions to this rule are streaming APIs, data transfer APIs, console access</p> <p>RR-15: Individual HTTP requests SHOULD be designed to complete fast (&lt; 0.5 second)</p> <p>The basic requirement is to design all remote API interactions to complete within short interval of time. This is important to develop responsive user interfaces as user interactions may need to block for the duration of an individual API call (see User Interface Timing Cheatsheet). If a back-end processing is expected to extend beyond the recommended limits then it should be split into several API interactions. For example a \"create report\" operation that may last 30 minutes can be split into \"create report request\" operation that accepts the inputs and return 202 (Accepted) with a tracking token identifying the request and a read operation to check the status of the request and obtain reference to the newly created report upon success.</p> <p>It is not uncommon that API operations become more complex as the product evolves. In case an operation duration extends in a subsequent product version alternative API may be offered that allows asynchronous execution</p> <p>Execution time may also depend on the size of environment or size of data relevant to the request. In this case an API can offer choice of synchronous and asynchronous execution.</p> <p>A notable exception to this rule are HTTP streaming APIs using technologies such as Comet or Server Sent Events.</p> <p>RR-16: Protocol &amp; framework timeouts SHOULD be used appropriately</p> <p>At VMware we have sometimes neglected those mechanisms and been left with hard to diagnose and solve issues e.g. PR 1591780 and PR 1506115. For example clients may find &lt; 15 seconds TCP connect timeout and TCP read timeouts of &lt; 2 minutes to work well. Similarly servers must be designed such that they can answer requests swiftly and report a re-triable error in cases when things go wrong. These may be dangerous if they spawn many re-tries so implementations should also be able to recognize such conditions and avoid failure.</p> <p>RR-17: API operations SHOULD provide means to recover from network failure</p> <p>Even with APIs designed to complete fast it is not impossible for network failure to occur while request is in progress. In those circumstances client should have a reliable way to resume its intended workflow once network connectivity is restored. One way to achieve such reliability is to design mutation APIs such that they allow to be retried without negative consequences.</p> <p>RR-18: API operations SHOULD provide adequate concurrency controls</p> <p>As scale is increased the probability of an entity being read and modified near simultaneously from concurrent workflows increases. To avoid race conditions in such scenarios APIs should define clear concurrency semantics and provide adequate protection mechanisms against concurrency errors. Examples of such mechanisms include last writer wins, optimistic locking through ETags (see HTTP Etag Wikipedia article)</p>"},{"location":"api/api-guidelines/#basic-constructs","title":"Basic Constructs","text":""},{"location":"api/api-guidelines/#data-types","title":"Data Types","text":"<p>CNST-1: JSON representations MUST NOT include type information except for discriminating between alternative object types.</p> <p>As the REST APIs may be used by humans directly or developers may want to craft simple SDKs by hand it is important to make data representations simple and intuitive. To this end we expect APIs to not obfuscate JSON with extensive schema information. If schema information is provided it SHOULD be out of band e.g. in an API definition such as Swagger, RAML or WADL file/resource. It is ok to include type identifiers and auxiliary data in server responses that is needed to operate the API. (See Example Xenon response)</p>"},{"location":"api/api-guidelines/#primitive-types","title":"Primitive types","text":"<p>CNST-2: REST services SHOULD apply the robustness principle (aka Postel's law) to tolerate slight variations in input while being strict in producing output</p> <p>CNST-3: REST services SHOULD use the primitive types defined in JSON RFC 8259 and JSON Schema</p> <p>The following table lists the JSON types.</p> Type Sample Description true / false true Two state variable. While RFC 8259 is pretty clear regarding the values representing true and false services often tolerate other commonly accepted representations as inputs e.g. 1 and 0, \"True\" and \"False\" string literals etc. string \"Hello World!\" A quoted unicode sequence of characters number 1.61803398875 JSON specifies only one number format. Services may specify additional validation constraints - whole numbers, byte, 32 bit integer etc. null null useful for denoting unset value e.g. to disable a policy it may be useful to unset it. In PATCH partial updates null may be interpreted differently from missing value i.e. null resets field to null, missing leaves the old value. The behavior should be specified for each products/component. object { \"answer\" : 42 } represents an object or map array [30, 42] represents ordered list of elements <p>On top of the basic JSON types through syntax restrictions JSON schema and VMware practice define additional useful data types</p> Restriction Sample Description date-time 2004-07-25T06:18:20.521-04:00 String representing date and/or time values encoded as per JSON Schema (ISO 8601, RFC 3339 section 5.6) email jdoe@aol.com email address as per JSON schema hostname nimbus.eng.vmware.com hostname as per JSON schema ipv4 192.168.4.1 IPv4 address as per JSON Schema ipv6 FEDC:BA98:7654:3210:FEDC:BA98:7654:3210 IPv6 address as per JSON Schema uri ftp://joe:secret@ftp.mysite.com URI as per JSON schema Binary SGVsbG8gV29ybGQh String value containing base64 encoded binary data. This is suitable for small amounts of binary data like hashes, public keys etc. This is not defined in JSON Schema but is used in several VMware APIs. integer 42 a number without fractional component. In JSON schema defined as multiple of 1"},{"location":"api/api-guidelines/#objects","title":"Objects","text":"<p>JSON objects are to be used for representing objects and maps.</p> <p>In most cases the schema of an object is clear from its context. For example virtual machine create operation accepts a JSON object with predefined set of members.</p> <p>In some occasions the type of object may not be clear from context. In those cases a type discriminator member is to be used to identify the correct type.</p> <p>Typical use cases that require use of type discriminator include:</p> <ol> <li>Errors - error types typically share most of their members however the semantics are vastly different based on the type of error.</li> <li>Extensible Polymorphic resources - when a given object can be one of several complex semantic types</li> </ol> <p>CNST-4: If type discriminator is to be included it SHOULD be the first member of a serialized object.</p> <p>Below is example polymorphic object from NSX API.</p> <pre><code>// OK - resource_type member indicates the type of an object that may be one of several types\n{\n    \"resource_type\": \"SpoofGuardSwitchingProfile\",\n    \"display_name\": \"spoof-guard-lswitch-bindings\",\n    \"white_list_providers\": \"LSWITCH_BINDINGS\"\n}\n</code></pre> <p>Alternative way to represent type discriminators is by using member name i.e. in a parent object only one of a set of members is set at a time and each member name is associated with specific type. For example a schema may contain <code>result</code> and <code>error</code> fields to represent the result of an operation.</p> <pre><code>{\n   \"error\" : {\n      \"error_type\": \"com.vmware.vapi.std.errors.invalid_argument\"\n   }\n }\n</code></pre> <p>CNST-5: Type discriminators SHOULD be used sparingly.</p> <p>For example it is NOT OK to use type discriminators for primitive types across the board, thereby embedding schema information in the payload. Instead out of band schema of the containing object should define the type of a member.</p> <p>Good example</p> <pre><code>{\n    \"age\" : 35\n}\n</code></pre> <p>NOT OK</p> <pre><code>{\n  \"age\": { \"int\" : \"35\" }\n}\n</code></pre> <p>See NSX T Switching Profiles</p>"},{"location":"api/api-guidelines/#naming-conventions","title":"Naming Conventions","text":"<p>In June 2014 a discussion was held in the OCTO API group around naming of parameters in REST APIs (see Field naming debate). A consensus was reached that</p> <p>CNST-6: JSON object member names SHOULD use lower_snake_case</p> <p>Example: <code>\"resource_description\": \"A description\"</code></p> <p>CNST-7: URIs SHOULD use kebab-case</p> <p>Example: <code>/my-resources/123</code></p> <p>The above rule applies only to the predefined segments of the URI path. When identifier or enumeration values are part of a URI as parameters their values should not be modified to follow the above guidance.</p> <p>CNST-8: Enumerated values SHOULD use UPPER_SNAKE_CASE</p> <p>Example: <code>\"state\": \"POWERED_OFF\"</code></p> <p>Following the guidance for JSON object member names</p> <p>CNST-9: Query parameter names SHOULD use lower_snake_case</p> <p>Example: <code>/virtual-machines?power_state=POWERED_OFF</code></p> <p>The HTTP RFCs define a number of standard headers using kebab-case. For example the conditional headers defined in RFC 7232 last-modified, if-match etc. HTTP header hames should be treated as case insensitive as per HTTP 1.1 RFC 7230. As per HTTP/2 RFC 7540 header names must be lower cased before transmission. To clearly define the API contract the following guidance to header names applies</p> <p>CNST-10: Header parameter names SHOULD use lower-kebab-case</p> <p>Example: <code>record-offset: 13</code></p> <p>Below is an example illustrating full request:</p> <p>PREFERRED</p> <pre><code>PUT /my-resources/123?update_details=true\nif-match: \"182584fa-1767-410e-9b63-ea8bc07b8d2f\"\n</code></pre> <pre><code>{\n    \"resource_name\": \"test\",\n    \"resource_description\": \"A description\",\n    \"state\": \"POWERED_OFF\"\n}\n</code></pre> <p>Acceptable for PRE EXISTING APIs - as previously discussed PascalName and camelCase have certain issues we want to avoid. It is not nice to use mixed case URIs from usability perspective</p> <pre><code>PUT /myResources/123\n{\n    \"resourceName\": \"test\", // camelCase identifier is problem\n    \"ResourceDescription\": \"A description\", // PascalName identifier is problem\n    \"state\": \"powered-on\" // kebab-case enumerated value is problem\n}\n</code></pre> <p>Some of our products use CamelCase and/or mixedCase identifiers. In those cases for consistency it is preferable to retain the existing convention.</p>"},{"location":"api/api-guidelines/#uri-structure","title":"URI Structure","text":"<p>CNST-11: The URI SHOULD identify the component/product and resource type being accessed</p> <p>Example: <code>/vcenter/folders</code></p> <p>CNST-12: The URIs SHOULD use plural names for resources</p> <p>Example: <code>/content/libraries</code></p> <p>Abbreviations in APIs should be generally avoided except when those are industry standard. In cases when abbreviations are used they should be pluralized according to Chicago Manual of Style.</p> <p>CNST-13: Components SHOULD be able to handle a base URI prefix dependent on the packaging and deployment (suite , product etc.) The suggested structure of the URI is as follows <code>{base URI}/{component}/{resource}</code></p> <pre><code>GET https://sddc.vmware.com/content/libraries/{library-id}\n// https://sddc.vmware.com/ - base URI\n// content - product/component namespace\n// libraries/{library-id} - resource\n</code></pre> <p>CNST-14: URIs SHOULD NOT contain redundant names</p> <p>Bad example</p> <pre><code>GET https://sddc.vmware.com/vcenter/vm/vm/{vm}\n</code></pre> <p>CNST-15: Resource names SHOULD be simple nouns expressing only the semantics of the resource</p> <p>Avoid using suffixes in resource URIs like -resource, -service etc.</p> <p>Good example</p> <pre><code>GET https://sddc.vmware.com/vcenter/vm/vm-104\n</code></pre> <p>Bad example</p> <pre><code>GET https://sddc.vmware.com/vcenter/vm-resource/vm-104\n</code></pre>"},{"location":"api/api-guidelines/#hyperlinks","title":"Hyperlinks","text":"<p>Important aspect of REST APIs is hyperlinking of resources. Hyperlinks allow clients to navigate the API with limited or no out of band knowledge of the system. VMware APIs and the use cases we see from clients imply out of band knowledge of the API semantics and syntax. Thus the hyperlinks serve a secondary purpose for the API consumer. For example a hyperlink may navigate the consumer to particular node or service instance in a scaled out environment. Hyperlinks may also be useful to traverse a collection, locate parent resource and a number of other common use cases. Yet even in those cases compiled clients like SDKs and reflective clients like CLIs may find it easier to use application defined identifiers that are to be placed inside subsequent request in RPC manner instead of utilizing hyperlinks. The goal of this chapter of the standard is to set out syntax guidelines for rendering hyperlinks such that clients know how to find, understand the semantics of and use the hyperlinks in an API response.</p> <p>CNST-16: An API response MAY provide hyperlinks to related resources.</p> <p>In defining the link syntax we want to leverage existing standards. There is not yet a widely accepted JSON standard for hyperlink representation. Following review of industry practices Hypertext Application Language (HAL) seems to come closest to a standard for JSON link representation.</p> <p>CNST-17: Links MUST be rendered within <code>_links</code> JSON object member.</p> <p>CNST-18: Links MUST be represented as object or array members of the <code>_links</code> object.</p> <p>CNST-19: The names of members of the <code>_links</code> object MUST use the name of the member they relate to or standard IANA link relation names.</p> <p>CNST-20: Multiple links sharing the same relation value MUST be represented as array of link objects.</p> <p>CNST-21: Link objects MUST have <code>href</code> member containing target URL.</p> <p>It may be beneficial to include additional data about a linked resources in hyperlinks. Such data may include the type of linked resource or properties of the linked resource needed for display purposes among others.</p> <p>CNST-22: Link objects MAY have additional members to complement their semantics.</p> <p>Example:</p> <pre><code>{\n   \"host\": \"host-12\",\n   \"disks\": [\"IDE0:1\", \"IDE1:0\"],\n   \"_links\": {\n      \"self\": {\n         \"href\": \"http://vc.coke.com/api/vcenter/vms/vm-42\"\n      },\n      \"host\" : {\n         \"href\": \"http://vc.coke.com/api/vcenter/hosts/host-12\",\n         \"title\": \"RDVC_ESX13\"\n         },\n      \"disks\" : [ {\n            \"href\": \"http://vc.coke.com/api/vcenter/vms/vm-42/disks/IDE0:1\",\n            \"id\": \"IDE0:1\"\n         }, {\n            \"href\": \"http://vc.coke.com/api/vcenter/vms/vm-42/disks/IDE1:0\",\n            \"id\": \"IDE1:0\"\n         }\n      ]\n   }\n}\n</code></pre> <p>CNST-23: <code>href</code> values SHOULD be absolute URLs or absolute paths as defined by RFC 1808 Section 2.2.</p> <p>Absolute URLs start with a scheme and authority (hostname, IP, port number and possibly authentication data). Absolute paths start with a slash and represent resource on the same endpoint.</p> <p>For example:</p> <p><code>Absolute URL: http://cloud.vmware.com/sddcs/sddc-15</code></p> <p><code>Absolute Path: /sddcs/sddc-15</code></p> <p>In case a service is deployed behind a reverse proxy whose hostname may be hard to figure absolute paths may work better. Absolute paths may be useful as resource identifiers that clients cache and are immune to changes of service hostname. Absolute URLs may be useful in scaled out environments to navigate the users between different shards of a service.</p> <p>Use of paths relative to particular resource is discouraged. Those need to be interpreted in the context of a preceding request and require state on the client.</p>"},{"location":"api/api-guidelines/#http-verbs","title":"HTTP Verbs","text":"<p>A key aspect of modern APIs is uniformity of the interface (5.1.5 Uniform Interface; Architectural Styles and the Design of Network-based Software Architectures; R. Fielding, 2000). When modeling a REST API the majority of design should be focused on modeling the resource representation and how these will be used to drive the application state. This is in sharp contrast to modeling classic RPC APIs that focus on modeling operations through which the application state is manipulated. In a REST API a consumer interacts with a resource representation through standard HTTP operations. So consumers need not to care as much what operations are available as they would do in a traditional system. Instead API consumers focus on the resource model, resource representations and navigation to related/linked resources. Resources accessed via standardized set of verbs form the basis for automation and policy driven systems. The following rules capture the above intent when mapped to HTTP:</p> <p>VERB-1: API SHOULD be structured around resources identified through nouns in a resource URI</p> <p>VERB-2: Interaction with the API SHOULD happen through manipulation of resource representations via standard HTTP verbs</p> <p>Details about the patterns used with the various verbs follows</p> <p>VERB-3: APIs' contract MUST specify only one success response type for given request</p> <p>A response type is the combination of response body schema, HTTP status code and headers. Multiple types of success responses for given operation require a client to implement multiple handlers for the success of each operation. For example if API implementations can either return JSON or CSV it should be specified by the client accept header or default for the API contract. Another example is an API that can return task or block until the actual result is produced, in this case the selection should be made based on API default or client parameter. In the later example it would be inappropriate for server to make the choice of task or blocking based on internally estimated duration.</p> <p>VERB-4: If a URI supports PUT, POST or PATCH then it SHOULD support HTTP GET</p> <p>With very few exceptions all resource URIs should support HTTP GET operation. There may be rare exceptions for example a resource may support creation and lack list/query capability.</p> <p>Modeling API interaction through standard CRUD (Create, Read, Update, Delete) operations eases integration with desired state automation tools like Chef, Puppet, Ansible, Microsoft Desired State automation as generation of the integration code may be used. Thus it is recommended to model fully functional resource abstractions that allow POST to create, GET to read, PUT or PATCH for update and DELETE.</p> <p>VERB-5: Operations with side effects SHOULD accept client operation identifier tokens. These tokens allow clients to reconnect to an operation when client fail to receive the original response.</p> <p>The client token approach is employed by Amazon EC2 and vSphere Content Library API to assure at most once semantics.</p>"},{"location":"api/api-guidelines/#get","title":"GET","text":"<p>Retrieves a resource representation. Client requests a resource living on given URI and receives back a resource representation.</p> <p>VERB-6: GET request MUST retrieve resource representation</p> <p>VERB-7: GET operations MUST be safe to retry. (see RFC 7231 Section 4.2.1 Safe Methods )</p> <p>VERB-8: GET requests SHOULD not expect request body</p> <p>Safe to retry means that no significant side effects are exerted on the entity addressed by the request. It is possible that side effects are realized in form of log entries, last accessed time stamp etc.</p> <p>Sometimes functionality like lease/lifespan of objects may be affected by last accessed time. For example upload session lifespan may be managed by tracking access to it. Using GET requests for this use case may be tricky as GET result may potentially be cached by some intermediate result. It is recommended to increase leases with a POST request.</p> <p>Typical Patterns:</p> <ul> <li>GET /{singleton} - retrieve singleton representation e.g. /tagging/settings</li> <li>GET /{resource collection} - list/query entities e.g. /identity/api/tenants</li> <li>GET /{resource collection}/{id} - retrieve instance representation e.g. /identity/api/tenants/MYCOMPANY</li> <li>GET /{resource collection}/{id}/{fragment} - retrieve a fragment of a complex resource e.g. /vcenter/vm/vm-15/cpu</li> <li>GET /{resource collection}/{id}/{sub-resource collection} - list/query collection of sub-resources e.g. /identity/api/tenants/MYCOMPANY/directories.</li> <li>GET /{resource collection}/{id}/{sub-resource collection}/{sub-resource id} - retrieve a sub-resource instance e.g. /vcenter/vm/vm-15/disks/disk-2.</li> </ul> <p>Success response status codes:</p> <ul> <li>200 (Ok) on success completion</li> <li>304 (Not Modified) when client has the latest version of the resource and caching is supported (See RFC 7232 section 4.1)</li> </ul> <p>Example:</p> <pre><code>GET /tagging/categories/c78b51b9-da37-44c9-9ac4-14ed788cc583\n</code></pre> <pre><code>HTTP/1.1 200 OK\n\n{\n \"id\" : \"c78b51b9-da37-44c9-9ac4-14ed788cc583\",\n \"associable_types\" : [ \"VirtualMachine\" ],\n \"description\" : \"Desc Cat\",\n \"name\" : \"MyCategory\",\n \"used_by\" : [ ],\n \"cardinality\" : \"MULTIPLE\"\n}\n</code></pre>"},{"location":"api/api-guidelines/#patch","title":"PATCH","text":"<p>Creates or partially updates a resource. HTTP PATCH was introduced in RFC 5789 as an add-on to HTTP.</p> <p>Developers of PATCH APIs may be concerned about the availability of HTTP PATCH in specific tools or deployment environments. In those circumstances alternative access to the HTTP PATCH functionality SHOULD be provided. One way to achieve this is through POST (non-CRUD operations). Another example is using HTTP POST and X-HTTP-Method-Override.</p> <p>HTTP PATCH APIs are susceptible to concurrency issues when used in read-modify-write scenarios. It is recommended that optimistic concurrency control is employed to avoid mid-air collisions.</p> <p>HTTP PATCH is the preferred way to update a resource as it solves several complications present in HTTP PUT. PATCH allows only relevant subset of properties to be updated thus minimizing the opportunity for conflicts. PATCH input schema can be extended as the product evolves. JSON body members that are not specified by the client in a partial update remain unchanged.</p> <p>VERB-9: PATCH requests MAY be non-idempotent.</p> <p>VERB-10: PATCH requests MUST accept resource identifier(s) in the URI path and a document describing the changes in the body of the request</p> <p>VERB-11: PATCH requests SHOULD on success return either 200 (OK) with updated resource document alternatively it MAY return 204 (No-content) with empty document OR 202 (Accepted) with a task (tracking resource) OR 201 (created) code when a new instance is created.</p> <p>There are two general approaches to implement PATCH API in the industry that have gained prominence. The recommended in the general case practice is to use partial documents.</p> <ul> <li> <p>Accept partial document with only subset of the resource properties present. (RECOMMENDED) This is described in RFC 7386. The server only updates the properties found in the request document. JSON null in this case is used to signal the server to reset a property. This approach is not quite suitable for updating arrays as indiviudal array elements cannot be addressed. One approach for handling arrays is to accept three lists \u2014 new, to be deleted and to be updated. This approach of partial documents is adopted by VAPI Best Practices and Google Compute Engine API. The input for PATCH with partial document should resemble the output of a GET operation on the same resource.</p> </li> <li> <p>Accept list of instructions for updating the resource. This approach expects a list of statements each describing a modification to the resource representation e.g. update property X, unset property Y, add element to the end of a list, remove the third element etc. This approach to implementing PATCH makes it non-idempotent (e.g. remove third element). RFC 6902 - JavaScript Object Notation (JSON) Patch and VMware View employ this approach. This approach is more efficient if list manipulation is frequent use case. See example update from RFC 6902.</p> </li> </ul> <p>Typical Patterns:</p> <ul> <li>PATCH /{singleton} \u2014 update singleton representation e.g. /tagging/settings</li> <li>PATCH /{resource collection}/{id} \u2014 update or create a resource instance e.g. /vcenter/vm/vm-15</li> <li>PATCH /{resource collection}/{id}/{fragment} \u2014 update a fragment of a complex resource e.g. /vcenter/vm/vm-15/cpu</li> <li>PATCH /{resource collection}/{id}/{sub-resource collection}/{sub-resource id} \u2014 update or create a sub-resource e.g. /vcenter/vm/vm-15/disks/disk-2.</li> </ul> <p>Success response status codes:</p> <ul> <li>200 (Ok) in success update case when the updated resource representation is returned</li> <li>201 (Created) in case new resource has been created and its representation is returned</li> <li>202 (Accepted) when operation is performed asynchronously.</li> <li>204 (No Content) on success in case no message body is returned</li> </ul> <p>Example update using partial document:</p> <pre><code>PATCH /content/libraries/bbc7dd4f-0ece-4ad3-ae74-5547a0f2a5c9 HTTP/1.1\n{\n \"name\" : \"New library name\"\n}\n\nHTTP/1.1 200 OK\n</code></pre>"},{"location":"api/api-guidelines/#put","title":"PUT","text":"<p>Creates or replaces a resource.</p> <p>In accordance with RFC 7231 section 4.3.4 PUT performs full update (replacement) on a resource.</p> <p>PUT APIs SHOULD consider the impact of concurrent modifications and employ appropriate concurrency control mechanisms.</p> <p>HTTP PUT APIs are not extensible as the product evolves i.e. no new optional members can be added to their input. This is significant limitation for complex APIs. It is thus recommended to use HTTP PATCH for updates to allow the resource schema to be extended in the future.</p> <p>With HTTP PUT there is inherent risk of unrelated concurrent changes clobbering each other's effect. For example if 2 users make nearly concurrent updates to different properties of a resource it is possible that the changes of the first user are reverted by the second user. Optimistic locking may be employed to avoid collisions. HTTP standard headers ETag, If-Match may be used for optimistic locking. HTTP PATCH or fragment pattern allow for focused modifications within complex resources.</p> <p>A common use case involving PUT APIs is read-modify-write. An API user fetches resource representation using HTTP GET modifies some of the resource properties and PUTs back the modified resource document. This pattern allows developers to quickly apply the API for routine tasks.</p> <p>A subset of properties returned by HTTP GET may be read-only e.g. <code>resource identifier</code>, <code>revision</code> etc. HTTP PUT contract SHOULD be clear about handling of those properties. The general rule is to throw an error when attempt to modify read-only property is made. Throwing error will allow the contract to be updated in later version to allow modification of the property.</p> <p>A special kind of read only properties are system properties exposed by the programming framework. Those properties may never become writable. Such properties may include things like <code>last_modified</code>, <code>revision</code> etc. Servers SHOULD ignore such properties on input to PUT. Further servers may want to use special syntax for the names of such properties to distinguish them from properties innate to particular resource. For example NSX use underscore prefixed names for system properties. See also a Xenon example response</p> <pre><code>GET /api/realization-state-barrier/config\n</code></pre> <pre><code>{\n  \"resource_type\" : \"RealizationStateBarrierConfig\",\n  \"interval\" : 5000,\n  \"_revision\" : 0,\n  \"id\" : \"564dab50-63a0-8b4f-a1f8-20e4d36efc3b\",\n  \"_last_modified_user\" : \"admin\",\n  \"_last_modified_time\" : 1414088642536,\n  \"_create_time\" : 1414088642536,\n  \"_create_user\" : \"admin\"\n}\n</code></pre> <p>PUT requests should adhere to the following guidelines</p> <p>VERB-12: PUT requests MUST update the whole resource configuration with the supplied configuration. Properties that are not included in the request MUST be reset to default value.</p> <p>VERB-13: PUT requests MUST be idempotent i.e. it is safe to re-try a request multiple times</p> <p>VERB-14: PUT requests MUST accept resource identifier(s) in the URI path and a resource document in the body of the request</p> <p>VERB-15: PUT requests SHOULD on success return either 200 (OK) with updated resource document alternatively it MAY return 204 (No-content) with empty document OR 202 (Accepted) with a task (tracking resource) OR 201 (created) code when a new instance is created.</p> <p>VERB-16: PUT request body SHOULD accept the response body of GET on the same resource.</p> <p>VERB-17: PUT APIs SHOULD document the semantics of fields \u2014 writable, ignored or unmodifiable.</p> <p>Typical Patterns:</p> <ul> <li>PUT /{singleton} \u2014 set singleton representation e.g. /tagging/settings</li> <li>PUT /{resource collection}/{id} \u2014 set instance representation e.g. /vcenter/vm/vm-15</li> <li>PUT /{resource collection}/{id}/{fragment} \u2014 set a fragment of a complex resource e.g. /vcenter/vm/vm-15/cpu</li> <li>PUT /{resource collection}/{id}/{sub-resource collection}/{sub-resource id} \u2014 set a sub-resource e.g. /vcenter/vm/vm-15/disks/disk-2.</li> </ul> <p>Success response status codes:</p> <ul> <li>200 (Ok) in success update case when the updated resource representation is returned</li> <li>201 (Created) in case new resource has been created and it's representation is returned</li> <li>202 (Accepted) when operation is performed asynchronously.</li> <li>204 (No Content) on success in case no message body is returned</li> </ul> <p>Example:</p> <pre><code>PUT /tagging/categories/c78b51b9-da37-44c9-9ac4-14ed788cc583 HTTP/1.1\n{\n \"associable_types\" : [ \"VirtualMachine\" ],\n \"description\" : \"Desc Cat\",\n \"name\" : \"MyCategory\",\n \"used_by\" : [ ],\n \"cardinality\" : \"MULTIPLE\"\n}\n\nHTTP/1.1 200 OK\n{\n \"associable_types\" : [ \"VirtualMachine\" ],\n \"description\" : \"Desc Cat\",\n \"name\" : \"MyCategory\",\n \"used_by\" : [ ],\n \"cardinality\" : \"MULTIPLE\"\n}\n</code></pre>"},{"location":"api/api-guidelines/#delete","title":"DELETE","text":"<p>Deletes a resource instance.</p> <p>HTTP DELETE APIs are susceptible to concurrency issues and is possible for one user to delete an entity based on assumptions from recent read that are not true at time of deletion. It is recommended that optimistic concurrency control is employed to avoid mid-air collisions.</p> <p>VERB-18: DELETE requests MUST accept resource identifier(s) in the URI path</p> <p>Delete calls may accept additional optional parameters, for example to set expiration date for purging the resource.</p> <p>VERB-19: DELETE requests SHOULD on success return HTTP code 204 (no content) on success (200 OK or 202 Accepted are also acceptable but not recommended)</p> <p>VERB-20: DELETE requests SHOULD not expect request body</p> <p>Typical Patterns:</p> <ul> <li>DELETE /{resource collection}/{id} \u2014 delete a resource representation</li> <li>DELETE /{resource collection}/{id}/{sub-resource collection}/{sub-resource id} \u2014 delete a sub-resource instance e.g. /vcenter/vm/vm-15/disks/disk-2.</li> </ul> <p>Success response status codes:</p> <ul> <li>200 (Ok) in success delete case when document is returned</li> <li>202 (Accepted) when operation is performed asynchronously and task (tracking resource) is returned.</li> <li>204 (No Content) on success in case no message body is returned</li> </ul> <p>Example:</p> <pre><code>DELETE /tagging/categories/bbc7dd4f-0ece-4ad3-ae74-5547a0f2a5c9 HTTP/1.1\n\nHTTP/1.1 204 No Content\n</code></pre>"},{"location":"api/api-guidelines/#post-create","title":"POST (create)","text":"<p>Creates new resource instance.</p> <p>VERB-21: POST create request SHOULD on success return 201 (Created) code alongside resource document with populated auto-generated fields like ID, last update time etc. or 201 (Created) code alongside the ID of the new resource or 202 (Accepted) alongside a task (tracking resource) for asynchronous execution</p> <p>VERB-22: On success create operations SHOULD return a Location header with the URI of the new resource</p> <p>Typical Patterns:</p> <ul> <li>POST /{resource collection} \u2014 create new instance</li> <li>POST /{resource collection}/{id}/{sub-resource collection} \u2014 create new instance of a sub-resource e.g. /vcenter/vm/vm-15/disks.</li> </ul> <p>Success response status codes:</p> <ul> <li>201 (Created) in case new resource has been created and its representation is returned. It is acceptable to use 200 in legacy APIs.</li> <li>202 (Accepted) when operation is performed asynchronously and task (tracking resource) is returned.</li> </ul> <p>Response Headers:</p> <ul> <li>Location header SHOULD specify the location of the primary resource created by this operation RFC 7231 section 7.1.2</li> </ul> <p>Example:</p> <pre><code>POST /tagging/categories HTTP/1.1\n{\n \"name\" : \"Category name\",\n \"description\" : \"Category Description\",\n \"associable_types\" : [ \"Folder\" ],\n \"cardinality\" : \"SINGLE\"\n}\n\nHTTP/1.1 200 OK\nLocation: http://sddc.vmware.com/tagging/categories/9580d673-442d-44de-8839-dd7778c6179a\n\n\n{\n \"id\" : \"9580d673-442d-44de-8839-dd7778c6179a\"\n}\n</code></pre>"},{"location":"api/api-guidelines/#post-non-crud-operations","title":"POST (non-CRUD operations)","text":"<p>As we model complex systems there is the occasional case where modeling interactions purely through manipulating resource representations may be inefficient or increase API complexity substantially.</p> <p>Few examples that are not mapping well to resource property manipulation are:</p> <ol> <li>restart operation of a virtual machine operation performs a state transition of a virtual machine from \"powered on\" through some intermediate state, like \"off\", back to \"powered on\" state. Typically REST APIs will accept desired end state as value for a given property and it is thus not natural to model restart as value of power state property. In particular integrations with desired state systems could be made more difficult.</li> <li>batch operations act upon multiple resources</li> <li>complex queries require sophisticated specifications of projection, filter and pagination that may not be practical to include in a query string</li> </ol> <p>Industry experience also shows that sometimes modeling certain transition ought to happen through non-idempotent POST operation. (See It is ok to use POST, R. Fielding, 2009)</p> <p>Non-idempotent POST APIs may be susceptible to concurrency issues. Specific problem with non-idempotent APIs is that in case of network failure the client has to have way to recover through retrying the request or checking if the failed action has been enacted. It is recommended that optimistic concurrency control is employed to avoid mid-air collisions.</p> <p>VERB-23: APIs MAY model interactions through HTTP POST when modeling through resource manipulation is not natural</p> <p>VERB-24: Interactions modeled via HTTP POST MUST specify the operation as query string in the URI and accept parameters in the message body</p> <p>Typical Patterns:</p> <ul> <li>POST /{singleton}?action={action} - perform custom action on a singleton</li> <li>POST /{resource collection}?action={action} - batch operation on a set e.g. /vcenter/vm?action=reset</li> <li>POST /{resource collection}/{id}?action={action} - perform custom action on a resource representation e.g. /vcenter/vm/vm-24?action=reset</li> <li>POST /{resource collection}/{id}/{sub-resource collection}/{sub-resource id}?action={action} - custom action on sub-resources e.g. /vcenter/vm/vm-15/disks/disk-2?action=snapshot.</li> </ul> <p>Success response status codes:</p> <ul> <li>200 (Ok) in success completion case when document is returned</li> <li>202 (Accepted) when operation is performed asynchronously and task (tracking resource) is returned.</li> <li>204 (No Content) on success in case no message body is returned</li> </ul> <p>To illustrate the above a good example for POST API that does not fit well into CRUD is as follows:</p> <pre><code>POST https://{server}/vcenter/vm/{vm}/power?action=reset\n</code></pre> <p>Batch example:</p> <pre><code>POST /vcenter/vm?action=reset\n{\n    \"ids\" : [\"vm-15\", \"vm-234\", \"vm-111\"]\n}\n</code></pre> <p>We should avoid this pattern when API is better modeled via CRUD manipulation. Consider the following poor example that is much cleaner represented with HTTP DELETE:</p> <pre><code>POST /vcenter/vm/{vm}?action=delete\n</code></pre>"},{"location":"api/api-guidelines/#api-patterns","title":"API Patterns","text":"<p>This chapter presents useful API modelling patterns.</p>"},{"location":"api/api-guidelines/#long-running-operations","title":"Long-running operations","text":"<p>Often back end processing to achieve certain goal will exceed acceptable time limits for an HTTP request. In those cases APIs must define their interaction model to return fast from individual HTTP transactions and allow clients to monitor progress and obtain final result asynchronously. There are several design patterns that are commonly employed depending on the use case and product specifics. These include tasks (tracking resources), resource status, desired/realized state. API implementations may offer one of those or a combination. For example NSX is offering mix of tasks (tracking resources) and Desired/Realized state.</p> <p>There are some common good practices when exposing long-running operations</p> <p>PTRN-1: Clients MUST have an option to invoke a long-running API using one of the long-running operation models described above so that the client can implement for example, a responsive UI or pipelined automation script.</p> <p>From API implementer's view it is hard to assess the duration and reliability of given API operation as APIs may evolve to have more complex processing in future versions or clients may be on particularly unstable networks. It is thus expected that all mutation APIs should provide the option to start an operation with initial call and poll for progress and completions using subsequent requests. Certain APIs may provide additional option to wait for the result on the first request while others may only have the polling model.</p> <p>PTRN-2: Long-running APIs SHOULD perform as much as possible validation and report most errors during the initial interaction.</p>"},{"location":"api/api-guidelines/#resource-state","title":"Resource State","text":"<p>One way to track completion of long-running operations on a resource is to provide resource state field or fragment that indicates if the resource is undergoing reconfiguration. This technique is used by OpenStack Nova API, NSX API.</p> <p>A simple example of this type of APIs is OpenStack Nova server (virtual machine) provisioning. (See full example)</p> <ol> <li>End user requests new server via <code>POST /v2.1/servers</code></li> </ol> <pre><code>POST http://os.vmware.com/v2.1/servers\n</code></pre> <ol> <li>OpenStack returns skeleton object with self link to the server resource</li> </ol> <pre><code>202 Accepted\nLocation: http://os.vmware.com/v2.1/servers/b85ebd3b-df19-47f7-8116-ce99f00363cb\n\n{\n  \"server\":{\n     \"id\":\"b85ebd3b-df19-47f7-8116-ce99f00363cb\",\n     \"links\":[\n        {\n           \"href\":\"http://os.vmware.com/v2.1/servers/b85ebd3b-df19-47f7-8116-ce99f00363cb\",\n           \"rel\":\"self\"\n           .........\n</code></pre> <ol> <li>The server is in <code>BUILD</code> state</li> </ol> <pre><code>GET http://os.vmware.com/v2.1/servers/b85ebd3b-df19-47f7-8116-ce99f00363cb\n\n200 OK\n\n{\n  \"server\":{\n     \"status\":\"BUILD\",\n     . . . .\n  }\n  . . . .\n}\n</code></pre> <ol> <li>Actual provisioning completes and server goes to <code>ACTIVE</code> state or if creation fails the server goes to <code>ERROR</code> state.</li> </ol> <pre><code>GET http://os.vmware.com/v2.1/servers/b85ebd3b-df19-47f7-8116-ce99f00363cb\n\n200 OK\n\n{\n  \"server\":{\n     \"status\":\"ACTIVE\",\n     ........\n  }\n}\n</code></pre> <p>In order to use this technique for create operations the back end services should be able to swiftly validate the request, allocate resource identifier, persist the entity description and return to the client. It is still possible that the actual creation in the backing system may fail due to conditions that cannot be validated upfront. If create failure is to occur the resource should be moved to ERROR state and the API client is then responsible to delete it or modify their requirement such that system can fulfill it.</p> <p>The state property may be included inside the resource document (OpenStack) or in a fragment (NSX). The fragment approach has the advantage that the status properties are cleanly separated from the desired state properties of a given resource.</p> <p>Example of state fragment for logical switch from NSX API</p> <pre><code>GET https://&lt;nsx-mgr&gt;/api/logical-switches/cc5ff938-6f09-4841-8f0f-294e86415472/state\n\nSuccessful Response:\n\n{\n  \"state\" : \"in_progress\",\n  \"logical_switch_id\": \"cc5ff938-6f09-4841-8f0f-294e86415472\",\n  \"details\": [\n    {\n      \"state\" : \"in_progress\",\n      \"sub_system_id\" : \"366048ba-89d9-435e-ac2e-2c7cf6ed0f33\",\n      \"sub_system_type\" : \"TransportNode\"\n    }\n  ]\n}\n</code></pre>"},{"location":"api/api-guidelines/#tasks","title":"Tasks","text":"<p>This is the most widely used approach at VMware for dealing with long-running operations also employed by Google Compute Engine, some Microsoft and some Amazon APIs. The essence of the approach is to return HTTP 202 code and a tracking task resource to the API client after some basic request validation. Further the client can obtain progress updates and final operation status from the tracking resource.</p> <p>PTRN-3: Operation contracts MUST specify whether the operation return type is task or actual result.</p> <p>An API can provide two operations with different HTTP request signatures for API consumers to select between task and actual result return types.</p> <pre><code>// Operation that will block the request until completion\nPOST /vm?action=power-off\n\n// Operaiton with task\nPOST /vm?action=power-off&amp;vmw-async=true\n</code></pre> <p>There are two ways to include tasks in operation contracts</p> <ol> <li>Client preference in NSX API clients may request task to be used for any API operation by passing additional \"vmw-async\" query parameter in the request. This model allows API clients to assess the risks of network issues or ability to retry given call and make choice if the added overhead of polling is worth it.</li> <li>API designer preference for some APIs the complexity of an operation may be such that it will rarely complete in one HTTP request/response cycle. In those cases API designer may declare an API to explicitly return only tasks and not have option of execution in single request/response.</li> </ol> <p>PTRN-4: The task resource SHOULD contain at minimum the following information:</p> <ul> <li>state of the operation - at minimum the following states need to be present &gt; - running, success, error</li> <li>creation time of the task</li> <li>completion time of the task</li> <li>error object if the task execution fails</li> <li>identifier of the resource upon which the tracked operation is working.</li> <li>the operation-specific result of the invoked operation</li> </ul> <p>The results of many write operations in REST API are void or single resource identifier. In those cases pointer to the resource upon which the task operation is carried out suffices. Clients can use subsequent <code>GET</code> operation on the modified resource to learn more.</p> <p>Some REST operations produce actual return payload e.g. complex queries (reports). When those are executed using tasks the response field is to contain the actual operation result. The type of object included in the response should be identified with a type discriminator, so API clients know how to interpret it (see Objects). The result may be embedded in the task resource or provided as separate fragment resource e.g. <code>GET /api/tasks/{task-id}/response</code>. When the result is embedded in the task resource the task read operation may allow clients to request or suppress inclusion of result field.</p> <p>Example of task from NSX API</p> <pre><code>Request:\nGET https://&lt;nsx-mgr&gt;/api/tasks/ab265781-c826-4da7-9487-48a5c713a481\n\nResponse:\n200 OK\n\n{\n  \"progress\" : 100,\n  \"id\" : \"ab265781-c826-4da7-9487-48a5c713a481\",\n  \"end_time\" : 1416959364977,\n  \"status\" : \"success\",\n  \"async_response_available\" : false,\n  \"cancelable\" : false,\n  \"start_time\" : 1416959362874\n}\n</code></pre> <p>Example of task response fragment from NSX API for a Transport Zone creation operation. The <code>resource_type</code> field tells the client the type of entity returned</p> <pre><code>Request:\nGET /api/tasks/860f8b82-7983-4274-b275-ccdebb666ec7/response\n\nResponse:\n{\n    \"resource_type\": \"TransportZone\",\n    \"description\": \"Transport Zone 1\",\n    \"id\": \"a3097a9b-6429-499d-af21-7ae2bea5b1b9\",\n    \"display_name\": \"tz1\",\n    \"host_switch_name\": \"test-host-switch-1\",\n    \"transport_type\": \"OVERLAY\",\n    \"transport_zone_profile_ids\": [\n        {\n            \"profile_id\": \"52035bb3-ab02-4a08-9884-18631312e50a\",\n            \"resource_type\": \"BfdHealthMonitoringProfile\"\n        }\n    ],\n    \"_create_time\": 1474469755392,\n    \"_last_modified_user\": \"admin\",\n    \"_system_owned\": false,\n    \"_last_modified_time\": 1474469755392,\n    \"_create_user\": \"admin\",\n    \"_revision\": 0,\n    \"_schema\": \"/api/schema/TransportZone\"\n}\n</code></pre> <p>List of recent tasks is often displayed in user interfaces.</p> <p>PTRN-5: Service MAY implement task collection resource. The task collection SHOULD allow sorting and filtering tasks.</p> <p>Example from NSX API</p> <pre><code>GET /api/tasks\n</code></pre> <p>PTRN-6: As long-running operations may be taking up valuable system resources API to request task cancellation MAY be implemented</p> <p>It is up to the backend system to decide if task cancellation is to be honored or not.</p> <p>Example from NSX API</p> <pre><code>POST /api/node/tasks/{task-id}?action=cancel\n</code></pre> <p>Additional utility APIs for easier communication of the task changes may be implemented for example push APIs or long poll APIs.</p> <p>See NSX Task Management API</p>"},{"location":"api/api-guidelines/#file-transfers","title":"File Transfers","text":"<p>It is not uncommon for control and management APIs to require file or data transfer functionality. Such use cases include certificate files, configuration files, installation images, screenshots etc. This chapter contains guidance how to expose file &amp; large data transfer functionality in standard compliant and uniform manner.</p> <p>File transfer API is alternative to embedding base64 encoded binary content inside API JSON documents. As a rule of thumb large pieces of data need to use file transfer. File transfer semantics allow developers to recognize the demand for optimizing memory use. For example REST client implementations may assume JSON payloads fit in RAM while file transfers be streamed to disk before processing.</p> <p>PTRN-7: Binary data larger than several KiBs (at most 100KiB) MUST use file transfer pattern instead of embedding content in JSON</p>"},{"location":"api/api-guidelines/#file-or-data-download","title":"File or Data Download","text":"<p>Download is natural for the HTTP protocol and REST APIs. Download functionality is implemented by setting the appropriate media type of response and returning the file payload in the response body.</p> <p>Depending on the requirements download could be initiated with GET or POST (non-CRUD) operation.</p> <p>PTRN-8: Downloads SHOULD be tied to GET or POST (non-CRUD) operations</p> <p>Download of multiple pieces of data or files can be achieved using popular archive format like zip or by exposing a resource containing hyperlinks to downloadable files.</p>"},{"location":"api/api-guidelines/#file-or-data-upload","title":"File or Data Upload","text":"<p>Uploads are typically bound to HTTP PUT or POST (non-CRUD) operations.</p> <p>PTRN-9: Uploads SHOULD be tied to PUT or POST (non-CRUD) operations</p> <p>PTRN-10: Upload endpoints SHOULD accept requests with the appropriate media types e.g. <code>application/octet-stream</code>, <code>image/jpeg</code>, <code>application/xml</code> etc.</p> <p>Example:</p> <pre><code>PUT /vcenter/nsx/appliance/image\ncontent-type: application/octet-stream\n</code></pre> <p>PTRN-11: Multiple file upload APIs SHOULD use POST and <code>multipart/form-data</code> media type as defined in RFC 7578.</p> <p>Example:</p> <pre><code>POST /vcenter/nsx/appliance/images\ncontent-type: multipart/form-data; boundary=----content-273def1ef51c\ncontent-length: 12345671\n\n------content-273def1ef51c\ncontent-disposition: form-data; name=\"files\"; filename=\"settings.xml\"\ncontent-type: application/xml\ncontent-length: 45670\n\n[[File content here]]\n------content-273def1ef51c\ncontent-disposition: form-data; name=\"files\"; filename=\"image.ova\"\ncontent-type: application/vmware\ncontent-length: 12299800\n\n[[File content here]]\n------content-273def1ef51c\n</code></pre> <p>See also:</p> <ul> <li>OpenAPI 3.0 \u2014 considerations for file uploads</li> <li>OpenAPI 3.0 \u2014 considerations for multipart content</li> <li>OpenAPI file upload guidelines</li> <li>OpenAPI multipart request guidelines</li> </ul>"},{"location":"api/api-guidelines/#api-errors","title":"API Errors","text":"<p>PTRN-12: Errors reported by APIs MUST use the HTTP Response Status Code semantics RFC 7231 Section 6 HTTP Response Status Codes</p> <p>Errors reported through the API must respect the HTTP Response Code semantics. This guarantees that widest range of clients can handle the error conditions in appropriate manner such as report the error to the end user, retry the operation later, remove non-existent entries from cache etc..</p> <p>There may be need for some additional consideration when selecting an error code. For example to prevent leakage of information about resource existence 404 Not Found error may be reported when user lacks visibility of a resource. 403 Forbidden may be reported when user has visibility of a resource and specific action on the resource is disallowed e.g. deleting the resource. (See RFC 7231, Section 6.5.3. 403 Forbidden)</p> <p>PTRN-13: Error payload SHOULD contain additional error identification details</p> <p>In many scenarios the HTTP response code semantics are insufficient to communicate in sufficient detail the nature of the error that has occurred. API authors should add a member in the error payload that disambiguates such conditions.</p> <p>PTRN-14: Error payload SHOULD contain appropriate error messages</p> <p>VMware software is often used in data center context by system administrators and when errors occur it is important to report sufficient detail about the error to enable troubleshooting. Thus it is important to include human readable messages in the error payload.</p> <p>Localization is particular concern with error messages in APIs. With REST APIs at VMware we have adopted several distinct approaches to localizing error messages:</p> <ul> <li>API Server localizes - in this case the client sends desired locale in a Accept-Language header. The server generates the messages in the desired locale and sends them back. (See vCloud Air API - vCloud API REST Requests)</li> <li>API client localizes - in this case the API returns message keys and parameters. The API client has to download localization bundles, look up the received message keys and format the parameters in the message.</li> <li>Combined (recommended) - In this case the API returns both localized messages, message keys and parameters necessary for delayed localization</li> </ul> <p>Server side localization is obvious choice when creating system administrator focused user interfaces. This approach is not very usable if the API is invoked through a workflow solution that may need to report errors at a later time possibly in a yet to be determined locale.</p> <p>To cater for the complex cloud stack that includes workflow solutions client side localization is useful. For example vRealize Automation can store messages from vCenter and ESX for a specific failed service request. vRA could then present the error messages to a system administrator in their desired locale at later point of time.</p> <p>The client side localization approach makes it simpler to code service oriented application where the actual execution and potential error messages may originate from various services.</p> <p>Thus we suggest that VMware REST APIs allow for both mechanisms to exist simultaneously. It is acceptable to have the server side localization done in one locale fixed per product or deployment.</p> <p>PTRN-15: Error payload MAY contain additional data relevant to the error</p> <p>Error handling code often depends on certain supplementary data. Such data may at the discretion of the API designer be added to the error payload and SHOULD be appropriately documented.</p> <p>Below is example error response following the above rules:</p> <pre><code>POST /tagging/tag HTTP/1.1\n\n{\n   \"name\" : \"test\"\n}\n\n\nHTTP/1.1 400 Bad Request\n\n{\n    \"messages\": [\n        {\n            \"id\": \"vapi.invoke.input.invalid\",\n            \"default_message\": \"Unable to validate input to method com.vmware.cis.tagging.tag.create\",\n            \"args\": [\n                \"com.vmware.cis.tagging.tag.create\"\n            ]\n        },\n        {\n            \"id\": \"vapi.data.structure.field.invalid\",\n            \"default_message\": \"Found invalid field create_spec in structure.\",\n            \"args\": [\n                \"create_spec\"\n            ]\n        },\n        {\n            \"id\": \"vapi.data.structure.field.missing\",\n            \"default_message\": \"Structure 'com.vmware.cis.tagging.tag.create_spec' is missing a field: description\",\n            \"args\": [\n                \"com.vmware.cis.tagging.tag.create_spec\",\n                \"description\"\n            ]\n        }\n    ],\n    \"type\": \"com.vmware.vapi.std.errors.invalid_argument\"\n}\n</code></pre>"},{"location":"api/api-guidelines/#error-response-codes","title":"Error Response Codes","text":"<p>Section 6.5 of RFC 7231 provides explanations of which response codes are appropriate in various error conditions. The RFC texts are domain agnostic and on many occasions further guidance to the use of HTTP codes is required. This section of the standard further clarifies the use of HTTP response codes for API design at VMware by discussing domain specific scenarios.</p> <p>In the absence of explicit guidance, RFC 7231 is considered authoritative.</p> <p>PTRN-16: APIs MUST respond with 403 when functionality is unavailable due to licensing</p> <p>If an API client makes a request requiring functionality that is available in some instances of the service but is not available in the requested instance because the current license does not support it, use a 403 response to indicate that access to the feature is currently forbidden.</p>"},{"location":"api/api-guidelines/#api-documentation","title":"API Documentation","text":"<p>DOC-1: There MUST be an API guide for the product which is delivered via the company web site without requiring access to the product so a customer can review the API without access to the product itself (i.e. on an airplane).</p> <p>DOC-2: There MUST be API documentation delivered as part of the product. This SHOULD be delivered as a URI available on the product's management system web server and SHOULD be linked from the help section of the GUI.</p> <p>DOC-3: The intended audience of the API guide are developers or operators intending to automate or integrate. The API guide is generally considered a reference document describing how to use the API and any relevant contracts about the behavior of the API. The API guide SHOULD NOT be a detailed document about how a feature or component is used and how it inter-operates with other system capabilities. This information is useful to the overall user base and SHOULD be in the administration guide.</p> <p>DOC-4: API examples MAY be delivered as part of developer network code examples and MAY be in the API guide.</p> <p>DOC-5: To save in effort and reduce the chance of errors the API guide MUST be automatically generated upon the build of the product.</p> <p>DOC-6: The API guide MUST document all publicly facing API resources and methods.</p> <p>DOC-7: There SHOULD be a general \"how to use the API\" section at the start of the API Guide document.</p> <p>DOC-8: There MUST be a way to search the API guide. If delivered in a chapter format this search MUST search across all chapters. If a single page in browser then the search MAY use the built in browser search. If delivered in a PDF then the search MAY use the built in PDF reader search.</p> <p>DOC-9: All deprecated API resources, methods, call, etc MUST be documented as such.</p> <p>DOC-10: Each resource SHOULD have a \"released in\" or \"introduced in\" field in the documentation.</p> <p>DOC-11: All API docs that are written by development SHOULD be approved by the documentation team.</p> <p>DOC-12: API doc styling SHOULD match the corporate standards in terms of colors, fonts, borders, etc.</p> <p>DOC-13: Some API documentation MAY be considered private or for registered partners only. These APIs MUST be documented in a separate API guide(s) and released only through appropriate channels i.e. the VMware developer center web site.</p> <p>DOC-14: The API guide SHOULD describe all error codes that could be experienced when operating the product and an associated description of the error code.</p>"},{"location":"api/api-guidelines/#api-evolution","title":"API Evolution","text":"<p>The fundamental goal is that evolving an API and its implementation should not break existing client code that is being used by VMware's customers or other VMware products. The value of VMware's products stems from operating together in an integrated environment with other VMware and partner products. When VMware releases a new product version that breaks this integrated environment customers will not be able upgrade. Such incidents are costly for customers, partners, and VMware.</p> <p>The best way to avoid breaking of existing client code is to only make backward compatible changes to the API definition and its implementation. Those changes include:</p> <ul> <li>Adding new resource URI</li> <li>Adding new HTTP verb on existing resource URI</li> <li>Adding new optional parameter (member of JSON body, header or query parameter)</li> <li>Adding new response element (member of JSON body, header parameter)</li> </ul> <p>Note that while many \"additive\" changes (e.g. new resources, new operations) are clearly backward compatible, additions to data structures (request/response bodies in REST) are a little more subtle. Additions to output data structures (response bodies in REST) are backward compatible, assuming that client code (including the de-serialization code used by the stubs) will ignore data they don't understand. Additions to input data structure (request bodies in REST) must be optional additions. Additions to HTTP PUT body data structures even when optional may introduce backwards incompatible behavior. In other words requests from old clients (that won't include the additions)must be accepted by the server and treated exactly as they were earlier.</p> <p>While we strongly discourage evolving the API and its implementation in ways that are not backward compatible and it should be avoided when there are alternatives, there are situations where there is no other alternative. To avoid breaking existing client code that is being used by VMware's customers when making incompatible changes to the API definition and its implementation, we need to communicate our intentions to our customer and partners and stage the changes in a way that allows them to migrate with us. Typically this involves:</p> <ul> <li>Making the new API available so that client developers can use it, while continuing to support the existing API.</li> <li>Documenting that the existing API is being deprecated and the the new API should be used instead</li> <li>Continuing to support the existing (deprecated) API for a period of time sufficient for the developers of the client code to switch to the new API and release new versions of the clients that don't use the deprecated API.</li> <li>Remove support for the deprecated API.</li> </ul> <p>Thus the formal requirements are:</p> <p>VER-1: API changes between versions MUST only include (1) Expanding the API surface in backwards compatible manner AND (2) Removing deprecated APIs when absolutely necessary and approved by product management.</p> <p>When an application is pointed to a REST API endpoint it is important for the application to know the version of API it is interacting with so as to select appropriate behavior. For example an API client built against release 7 has to avoid APIs added in release 7 when talking to release 6. The standard practice at VMware is to expose a resource that contains the version of the product and its API (See Multiple Versions of vSphere API)</p> <p>VER-2: APIs MUST expose a resource that clearly identifies the current API version</p> <p>Removing APIs introduces risk to product interoperability. It should be based on careful business analysis possibly using telemetry data. In essence removal of an API however unimportant it may seem makes the whole system API incompatible with prior releases and renders all existing VMware and 3rd party solutions incompatible until re-certified.</p>"},{"location":"api/api-guidelines/#dealing-with-incompatible-changes","title":"Dealing with incompatible changes","text":"<p>Sometimes substantial changes need to be made to existing resources that cannot be represented only as adding new properties and/or operations to existing resources. Such changes should be introduced as new APIs while the existing APIs preserve their compatible syntax and behavior.</p> <p>Introducing such new APIs depending on the scope of change may be limited to a single resource or as big as introducing new API for a given component.</p> <p>VER-3: Incompatible changes MUST be exposed under new URI and http verb combinations there by preserving the compatibility of prior APIs. Incompatible changes MUST NOT be introduced under same URI and verb combination using HTTP header.</p> <p>For example if one needs to introduce incompatible change to virtual machine migrate <code>POST /vm/{vm-id}?action=migrate</code> one should implement a new operation e.g. <code>POST /vm/{vm-id}?action=relocate</code>. This approach has been used widely in the industry e.g. Java introduced <code>ArrayList</code> in order to augment in incompatible way the behavior of <code>Vector</code>.</p> <p>In a different example if the vCenter content library component is to replace the local library concept with subscribable library leading to ripple changes to many other bits of the API it may be better to introduce the changes under new path as a brand new API set. For example the transition could be from <code>/content/local-library</code> to <code>/content/subscribable-library</code>. This later example should be used only in cases where major product changes are to happen e.g. merging two product lines. It is not acceptable to wholesale clone APIs for minor changes e.g. new fields to few resources. Industry example of this approach are Microsoft Azure APIs where the classic APIs were improved in the normal APIs. Another industry example is the evolution of Jackson API where new versions use new name space.</p>"},{"location":"api/api-guidelines/#api-versioning","title":"API Versioning","text":"<p>The goal of API versioning is to help managing the impact of breaking changes. When a large scale re-architecture of a product is taking place it is likely that impact on API will span multiple resources. API providers may choose to host the new APIs under a new semantically named hierarchy. Alternatively, often when dealing with a natural iteration of an existing API, API Providers may choose to adopt a versioning scheme on top of the existing semantical hierarchy.</p> <p>Following the general intent of this Standard, REST API versioning strives for achieving alignment across VMware products, while minimizing the effort required for adopting the new guidelines. This means that, in areas where there is more than one acceptable option, the Standard is biased towards the option that requires the least effort for adoption. As it currently stands, majority of VMware products either do not version REST APIs or version REST APIs using a versioning scheme, where the version information is present in a URI path segment, also referred as URI-based versioning. URI-based versioning is accepted as a standard pattern by multiple companies, such as Google and Microsoft, and is widely adopted by a large population of REST APIs. Hence, this Standard calls for adoption of URI-based versioning.</p> <p>VER-4: REST APIs SHOULD include version information in a URI path segment by using the lowercase letter 'v' followed by a string representing the REST API version.</p> <p>Using versions in URLs from the beginning is not required. APIs can adopt URI-based versioning whenever the need for that arises. API providers are not required to introduce versioning into existing APIs merely to comply with the guidelines. Instead, it is recommended to align with the versioning guidelines when a backward incompatible API change is introduced.</p> <p>VER-5: Released/GA versions of REST APIs MUST be represented by a single integer following the lowercase letter 'v', for example, 'v2'.</p> <p>Early/pre-GA versions may follow these conventions to clarify the in-development state of an API, for example:</p> <p>version</p> <p>description</p> <p>v2alpha</p> <p>Alpha release of version 2</p> <p>v2beta1</p> <p>Beta 1 release of version 2</p> <p>VER-6: Existing REST APIs that are not versioned MUST be considered version 1 (v1). If a new incompatible change is introduced using URI-based versioning it SHOULD start from version 2 (v2).</p> <p>This is to accept the possibility that the existing, non-versioned API can be perceived by API consumers as version 1. Hence, the next explicitly versioned API should be bumped up to version 2 to avoid confusion.</p> <p>VER-7: REST APIs MUST NOT use a different version negotiation mechanism, such as Accept and Content-Type headers or query parameters.</p> <p>The reason behind this is alignment and bias towards minimization of effort, as well as compatibility with commonly used interface definition languages (IDLs) and frameworks, such as VMODL2, OpenAPI 2.0 and 3.0. As mentioned above, most of the existing APIs either use URI-based versioning or do not version REST APIs. Alternative versioning approaches, such as supplying version information using a query parameter, are not natively supported by IDLs, such as OpenAPI 3.0.</p> <p>API providers are expected to align with the versioning standard when a new backward incompatible version is introduced. In such situations, it is the responsibility of the API provider to collaborate with the SDK team on communicating the change of the API versioning scheme to the developer community.</p> <p>VER-8: REST API versions MUST NOT be coupled with product or implementing service versions.</p> <p>REST API version is expected to change out of absolute necessity, at a much slower pace than product or implementing service versions. An example of that could be the necessity to introduce a breaking change or completely re-architect an existing API. These conditions are expected to be extremely rare as the REST API matures and gets adoped by consumers. In typical scenarios changes to APIs are expected to be backward compatible and should not require REST API version changes.</p> <p>VER-9: REST APIs URIs SHOULD be formatted in the following way: <code>http[s]://&lt;authority&gt;/[api/][&lt;namespace&gt;/][&lt;version&gt;/]&lt;path&gt;</code> Where:</p> <ul> <li>authority - <code>[userinfo@]host[:port]</code>. A single authority can be shared among multiple API providers.</li> <li>namespace - (optional) An arbitrary name pre-registered by an API provider as a grouping for a subset of APIs.</li> <li>version - The lowercase letter 'v' followed by a version identifier, for example: 'v3'.</li> </ul> <p>Namespaces may be omitted if the feature set is uniquely identified by the authority and the entire set of REST APIs hosted under the root level is expected to be versioned together.</p> <p>VER-10: REST API URIs SHOULD use <code>/api</code> as a URI path segment if explicit separation of API paths from non-API paths is required.</p> <p>The use of <code>/api</code> URI path segment is not necessary if such separation is clear from the API root or the namespace. For example:</p> <pre><code>    https://api.vmware.com/namespace/v1/path\n</code></pre> <p>If the base URL is shared between API and non-API resources, the use of the <code>/api</code> URI path segment is recommended.</p> <pre><code>    https://vmc.vmware.com/api/namespace/v1/path\n</code></pre> <p>VER-11: REST API versioning MAY be managed at an individual namespace level.</p> <p>Considering the differences in product and feature release cadence, some products or services may run into the need to change the REST API version while others may not. Namespaces provide a level of separation between groups of APIs.</p> <p>APIs under a specific namespace can be versioned independently. It is expected to have varying versions of APIs behind the same authority, for example:</p> <pre><code>https://gateway.vmware.com/api/namespace-a/v1/policies\nhttps://gateway.vmware.com/api/namespace-b/v2/resources\n</code></pre> <p>VER-12: Any version of a REST API MUST be complete and self contained and MUST NOT depend on other versions of the same REST API.</p> <p>When a new version of a REST API under a specific namespace is introduced, it must include all the features and capabilities and must not rely on the existence or make references to a different, such as older, version of the same API. APIs under different namespaces are versioned independently and can refer to each other.</p>"},{"location":"api/api-guidelines/#api-breaking-changes-and-deprecation","title":"API Breaking Changes and Deprecation","text":"<p>APIs are the capability that make a product larger than itself. They are the gateway to becoming an integrated part of a much larger ecosystem. This not only represents a large strategic value to VMware, but also a substantial risk to our customer's ecosystem that relies on our APIs to run their business. Customers also recognize this importance which is why there is an ever-increasing demand for a consistent deprecation (including all breaking changes) experience across all VMware products and services that they use. Because of this strategic need, VMware has standardized (via the BOSS Forum) on an universal, enterprise-wide API deprecation policy as summarized below. The formal standardization overview with all the details can be found here. This standard puts VMware in-line with industry practice of 12 months as seen in AWS, GCP and the Kubernetes Project. In future we may strengthen this promise to match VMware peers such as Azure and Salesforce.com with as long as 2 year deprecation periods.</p> <p>DR-1: Public APIs MUST be registered with developer.vmware.com along with associated lifecycle phase for each endpoint.</p> <p>This enterprise-wide requirement ensures that customer-facing APIs are clearly presented to customers and sets the appropriate expectation around the lifecycle phase of each API. This also allows product teams to clearly deliniate between Generally Available (GA)/Supported APIs, and those in an Unsupported/Pre-GA phase such as Beta or Experimental.</p> <p>DR-2: A 12-month advance End-of-Life (EOL) notice MUST be given for all breaking changes on APIs in a Supported/Generally Available (GA) state.</p> <p>With the clarity around which APIs are Supported/Generally Available (GA), VMware will be delivering contractual assurances to customers of 12-months advance notice before introducing a breaking change to all Supported/GA APIs. This advance notice will be limited to Supported/GA APIs; there is no guarantee associated with Pre-GA/Unsupported/Experimental APIs to allow product teams engineering agility early in the lifecycle of each API.</p> <p>DR-3: Customer notification of pending End-of-Life (EOL) or breaking changes MUST be given via Product Line Release Notes which starts the 12-month period</p> <p>While notice of API deprecation inside of an OpenAPI/Swagger Spec or other method is welcomed, there is a baseline requirement to notify VMware customers of pending API deprecation in the Product Line Release Notes. Publication of this document starts the clock on the 12-month period before introducing the breaking change.</p> <p>DR-4: Responses from deprecated APIs MAY use the <code>Deprecation</code> HTTP header to signal their API lifecycle status</p> <p>In addition to the above VMware wide policy authors of REST APIs may use the <code>Deprecation</code> and related headers defined in The Deprecation Header Field candidate RFC to convey details about the API deprecation status and expected sunset date.</p> <p>Example:</p> <pre><code>  Deprecation: Sun, 11 Nov 2020 23:59:59 GMT\n  Sunset: Wed, 11 Nov 2021 23:59:59 GMT\n  Link: &lt;https://api.example.com/v2/customers&gt;; rel=\"successor-version\",\n        &lt;https://developer.example.com/deprecation&gt;; rel=\"deprecation\"\n</code></pre> <p>Note: Once the RFC is approved this guideline will change to SHOULD and be updated according to the published RFC.</p> <p>Note: This requirement is not part of the VMware enterprise policy.</p>"},{"location":"api/api-guidelines/#appendix-a-reviewer-committee","title":"Appendix A - Reviewer Committee","text":""},{"location":"api/api-guidelines/#v-10","title":"v 1.0","text":"Christos Karamanolis Mitesh Pancholy Alan Renouf Gordon Good Greg Burk Kostadis Roussos Jim Stabile Chris Wagner Jeff Hu Alain Dumesny Pallavi Pangarkar Asaf Kariv Ken Ringdahl Andrew Voltmer Shaomin Chen Dale Olds Gopala Suryanarayana Robert Bosch Christophe Decanini Emad Benjamin William Lam Yashika Deva"},{"location":"api/api-guidelines/#v-20","title":"v 2.0","text":"Tim Binkley-Jones Jeff Hu Gordon Good Kashfat Khan Keith Farkas Yashika Deva Yavor Boychev Ravi Soundararajan Tim Whiffen Steven McAllister Karthik Murthy Brian Williams Dylan Thomas Fanny Strudel Kostadis Roussos Christian Dickmann Jason Chu Suren Balikyan Karthik Seshadri Eduard Zakaryan Zahari Ivanov Ina Uzunova Alex Rankov Eddie Dinel Patrick Barker George Dimitrov Peter Canning Martin Cvetanov <p>Document Editors - Kiril Karaatanassov, Avetik Hovhannisyan</p>"},{"location":"api/api-guidelines/#appendix-b-additional-examples","title":"Appendix B - Additional Examples","text":""},{"location":"api/api-guidelines/#partial-update-using-list-of-instructions","title":"Partial Update Using List of Instructions","text":"<p>Example for partial update using list of instructions from RFC 6902</p> <pre><code>An example target JSON document:\n\n   { \"foo\": [ \"bar\", \"qux\", \"baz\" ] }\n\nA JSON Patch document:\n\n   [\n     { \"op\": \"remove\", \"path\": \"/foo/1\" }\n   ]\n\nThe resulting JSON document:\n\n   { \"foo\": [ \"bar\", \"baz\" ] }\n</code></pre>"},{"location":"api/api-guidelines/#example-xenon-response","title":"Example Xenon Response","text":"<p>The <code>document*</code> fields are system properties in the following Xenon response. Those are generated by the framework.</p> <pre><code>    {\n       \"enumerationServiceReference\":\"http://172.20.0.221:62041/common/node-groups/default\",\n       \"enumerationAgentReference\":\"jsonrpc://172.20.0.221:62042\",\n       \"systemInfo\":{\n          \"properties\":{\n\n          },\n          \"environmentVariables\":{\n\n          },\n          \"availableProcessorCount\":0,\n          \"freeMemoryByteCount\":0,\n          \"totalMemoryByteCount\":0,\n          \"maxMemoryByteCount\":0,\n          \"ipAddresses\": [\n             \"172.20.0.221\"\n          ]\n       },\n       \"status\":\"UNKNOWN\",\n       \"serverId\":\"87084a1d-8d77-4295-aef4-f6bb957995d1\",\n       \"isRefreshRequired\":false,\n       \"documentSignature\":\"4322961ce952655c9ba7345e448e556a602e2c934c6f56ee72d1c07fb85907fe\",\n       \"documentUpdateTimeMicros\":1407472558278011,\n       \"documentVersion\":0,\n       \"documentKind\":\"com/dcentralizedsystems/services/peernodestate\",\n       \"documentSelfLink\":\"/common/node-groups/default/87084a1d-8d77-4295-aef4-f6bb957995d1\"\n    }\n</code></pre>"},{"location":"api/api-guidelines/#example-openstack-nova-server-provisioning","title":"Example OpenStack Nova Server provisioning","text":"<p>Example Contributed by Radoslav Gerganov (rgerganov@vmware.com)</p>"},{"location":"api/api-guidelines/#create-server-request","title":"CREATE SERVER REQUEST","text":"<pre><code>POST http://10.26.33.242:8774/v2.1/servers\nAccept: application/json\nUser-Agent: python-novaclient\nOpenStack-API-Version: compute 2.35\nX-OpenStack-Nova-API-Version: 2.35\nX-Auth-Token: {SHA1}4c9fd04a28c8b1df81de0689cbda4e2054439132\nContent-Type: application/json\n\n{\n   \"server\":{\n      \"min_count\":1,\n      \"flavorRef\":\"1\",\n      \"name\":\"fira12\",\n      \"imageRef\":\"83872a57-51e1-4546-b26f-bc73ebc5d26e\",\n      \"max_count\":1\n   }\n}\n</code></pre> <p>RESPONSE:</p> <pre><code>202 Accepted\nContent-Length: 376\nLocation: http://10.26.33.242:8774/v2.1/servers/b85ebd3b-df19-47f7-8116-ce99f00363cb Content-Type: application/json\nOpenstack-Api-Version: compute 2.35\nX-Openstack-Nova-Api-Version: 2.35\nVary: OpenStack-API-Version, X-OpenStack-Nova-API-Version X-Compute-Request-Id: req-53098894-aad9-4541-96b2-d4e886be88c0\nDate: Tue, 18 Oct 2016 12:13:40 GMT\nConnection: keep-alive\n\n{\n   \"server\":{\n      \"security_groups\":[\n         {\n            \"name\":\"default\"\n         }\n      ],\n      \"OS-DCF:diskConfig\":\"MANUAL\",\n      \"id\":\"b85ebd3b-df19-47f7-8116-ce99f00363cb\",\n      \"links\":[\n         {\n            \"href\":\"http://10.26.33.242:8774/v2.1/servers/b85ebd3b-df19-47f7-8116-ce99f00363cb\",\n            \"rel\":\"self\"\n         },\n         {\n            \"href\":\"http://10.26.33.242:8774/servers/b85ebd3b-df19-47f7-8116-ce99f00363cb\",\n            \"rel\":\"bookmark\"\n         }\n      ],\n      \"adminPass\":\"4Y3xdtLb8qAN\"\n   }\n}\n</code></pre>"},{"location":"api/api-guidelines/#poll-server-under-creation","title":"POLL SERVER UNDER CREATION","text":"<pre><code>GET http://10.26.33.242:8774/v2.1/servers/b85ebd3b-df19-47f7-8116-ce99f00363cb\nOpenStack-API-Version: compute 2.35\nUser-Agent: python-novaclient\nAccept: application/json\nX-OpenStack-Nova-API-Version: 2.35\nX-Auth-Token: {SHA1}4c9fd04a28c8b1df81de0689cbda4e2054439132\"\n</code></pre> <p>RESPONSE:</p> <pre><code>200 OK\nContent-Length: 1667\nContent-Type: application/json\nOpenstack-Api-Version: compute 2.35\nX-Openstack-Nova-Api-Version: 2.35\nVary: OpenStack-API-Version, X-OpenStack-Nova-API-Version\nX-Compute-Request-Id: req-c87efe63-c714-440e-9eda-951332b4e635\nDate: Tue, 18 Oct 2016 12:13:41 GMT\nConnection: keep-alive\n\n{\n   \"server\":{\n      \"OS-EXT-STS:task_state\":\"scheduling\",\n      \"addresses\":{\n\n      },\n      \"links\":[\n         {\n            \"href\":\"http://10.26.33.242:8774/v2.1/servers/b85ebd3b-df19-47f7-8116-ce99f00363cb\",\n            \"rel\":\"self\"\n         },\n         {\n            \"href\":\"http://10.26.33.242:8774/servers/b85ebd3b-df19-47f7-8116-ce99f00363cb\",\n            \"rel\":\"bookmark\"\n         }\n      ],\n      \"image\":{\n         \"id\":\"83872a57-51e1-4546-b26f-bc73ebc5d26e\",\n         \"links\":[\n            {\n               \"href\":\"http://10.26.33.242:8774/images/83872a57-51e1-4546-b26f-bc73ebc5d26e\",\n               \"rel\":\"bookmark\"\n            }\n         ]\n      },\n      \"OS-EXT-SRV-ATTR:user_data\":null,\n      \"OS-EXT-STS:vm_state\":\"building\",\n      \"OS-EXT-SRV-ATTR:instance_name\":\"instance-00000001\",\n      \"OS-EXT-SRV-ATTR:root_device_name\":null,\n      \"OS-SRV-USG:launched_at\":null,\n      \"flavor\":{\n         \"id\":\"1\",\n         \"links\":[\n            {\n               \"href\":\"http://10.26.33.242:8774/flavors/1\",\n               \"rel\":\"bookmark\"\n            }\n         ]\n      },\n      \"id\":\"b85ebd3b-df19-47f7-8116-ce99f00363cb\",\n      \"security_groups\":[\n         {\n            \"name\":\"default\"\n         }\n      ],\n      \"OS-SRV-USG:terminated_at\":null,\n      \"os-extended-volumes:volumes_attached\":[\n\n      ],\n      \"user_id\":\"5a83b2b6a1114dfc8523aa603a45e115\",\n      \"OS-EXT-SRV-ATTR:hostname\":\"fira12\",\n      \"OS-DCF:diskConfig\":\"MANUAL\",\n      \"accessIPv4\":\"\",\n      \"accessIPv6\":\"\",\n      \"OS-EXT-SRV-ATTR:reservation_id\":\"r-3t0rugpm\",\n      \"progress\":0,\n      \"OS-EXT-STS:power_state\":0,\n      \"OS-EXT-AZ:availability_zone\":\"\",\n      \"metadata\":{\n\n      },\n      \"status\":\"BUILD\",\n      \"OS-EXT-SRV-ATTR:ramdisk_id\":\"\",\n      \"updated\":\"2016-10-18T12:13:41Z\",\n      \"hostId\":\"\",\n      \"OS-EXT-SRV-ATTR:host\":null,\n      \"description\":null,\n      \"tags\":[\n\n      ],\n      \"key_name\":null,\n      \"OS-EXT-SRV-ATTR:kernel_id\":\"\",\n      \"locked\":false,\n      \"OS-EXT-SRV-ATTR:hypervisor_hostname\":null,\n      \"name\":\"fira12\",\n      \"OS-EXT-SRV-ATTR:launch_index\":0,\n      \"created\":\"2016-10-18T12:13:40Z\",\n      \"tenant_id\":\"b2ce2b442de94434b7ac40bf733db46a\",\n      \"host_status\":\"\",\n      \"config_drive\":\"\"\n   }\n}\n</code></pre>"},{"location":"api/api-guidelines/#poll-server-after-provisioning-is-completed","title":"POLL SERVER AFTER PROVISIONING IS COMPLETED","text":"<pre><code>GET http://10.26.33.242:8774/v2.1/servers/b85ebd3b-df19-47f7-8116-ce99f00363cb\nOpenStack-API-Version: compute 2.35\nUser-Agent: python-novaclient\nAccept: application/json\nX-OpenStack-Nova-API-Version: 2.35\nX-Auth-Token: {SHA1}4c9fd04a28c8b1df81de0689cbda4e2054439132\"\n</code></pre> <p>RESPONSE:</p> <pre><code>200 OK\nContent-Length: 1934\nContent-Type: application/json\nOpenstack-Api-Version: compute 2.35\nX-Openstack-Nova-Api-Version: 2.35\nVary: OpenStack-API-Version, X-OpenStack-Nova-API-Version\nX-Compute-Request-Id: req-7d5eb2a7-b2da-4710-aab1-ab48457daf7d\nDate: Tue, 18 Oct 2016 12:14:53 GMT\nConnection: keep-alive\n\n{\n   \"server\":{\n      \"OS-EXT-STS:task_state\":null,\n      \"addresses\":{\n         \"private\":[\n            {\n               \"OS-EXT-IPS-MAC:mac_addr\":\"fa:16:3e:5e:04:eb\",\n               \"version\":4,\n               \"addr\":\"10.0.0.2\",\n               \"OS-EXT-IPS:type\":\"fixed\"\n            }\n         ]\n      },\n      \"links\":[\n         {\n            \"href\":\"http://10.26.33.242:8774/v2.1/servers/b85ebd3b-df19-47f7-8116-ce99f00363cb\",\n            \"rel\":\"self\"\n         },\n         {\n            \"href\":\"http://10.26.33.242:8774/servers/b85ebd3b-df19-47f7-8116-ce99f00363cb\",\n            \"rel\":\"bookmark\"\n         }\n      ],\n      \"image\":{\n         \"id\":\"83872a57-51e1-4546-b26f-bc73ebc5d26e\",\n         \"links\":[\n            {\n               \"href\":\"http://10.26.33.242:8774/images/83872a57-51e1-4546-b26f-bc73ebc5d26e\",\n               \"rel\":\"bookmark\"\n            }\n         ]\n      },\n      \"OS-EXT-SRV-ATTR:user_data\":null,\n      \"OS-EXT-STS:vm_state\":\"active\",\n      \"OS-EXT-SRV-ATTR:instance_name\":\"instance-00000001\",\n      \"OS-EXT-SRV-ATTR:root_device_name\":\"/dev/sda\",\n      \"OS-SRV-USG:launched_at\":\"2016-10-18T12:14:50.000000\",\n      \"flavor\":{\n         \"id\":\"1\",\n         \"links\":[\n            {\n               \"href\":\"http://10.26.33.242:8774/flavors/1\",\n               \"rel\":\"bookmark\"\n            }\n         ]\n      },\n      \"id\":\"b85ebd3b-df19-47f7-8116-ce99f00363cb\",\n      \"security_groups\":[\n         {\n            \"name\":\"default\"\n         }\n      ],\n      \"OS-SRV-USG:terminated_at\":null,\n      \"os-extended-volumes:volumes_attached\":[\n\n      ],\n      \"user_id\":\"5a83b2b6a1114dfc8523aa603a45e115\",\n      \"OS-EXT-SRV-ATTR:hostname\":\"fira12\",\n      \"OS-DCF:diskConfig\":\"MANUAL\",\n      \"accessIPv4\":\"\",\n      \"accessIPv6\":\"\",\n      \"OS-EXT-SRV-ATTR:reservation_id\":\"r-3t0rugpm\",\n      \"progress\":0,\n      \"OS-EXT-STS:power_state\":1,\n      \"OS-EXT-AZ:availability_zone\":\"nova\",\n      \"metadata\":{\n\n      },\n      \"status\":\"ACTIVE\",\n      \"OS-EXT-SRV-ATTR:ramdisk_id\":\"\",\n      \"updated\":\"2016-10-18T12:14:50Z\",\n      \"hostId\":\"07493bd1d8cb9abaa5897b2f6f1143d6a1e75951a8ba4414588d5f48\",\n      \"OS-EXT-SRV-ATTR:host\":\"sof2-vapi-1-214\",\n      \"description\":null,\n      \"tags\":[\n\n      ],\n      \"key_name\":null,\n      \"OS-EXT-SRV-ATTR:kernel_id\":\"\",\n      \"locked\":false,\n      \"OS-EXT-SRV-ATTR:hypervisor_hostname\":\"domain-c7.EB3DD91F-0A06-4068-8B9F-64841FBF9C75\",\n      \"name\":\"fira12\",\n      \"OS-EXT-SRV-ATTR:launch_index\":0,\n      \"created\":\"2016-10-18T12:13:40Z\",\n      \"tenant_id\":\"b2ce2b442de94434b7ac40bf733db46a\",\n      \"host_status\":\"UP\",\n      \"config_drive\":\"True\"\n   }\n}\n</code></pre>"},{"location":"api/api-versioning/","title":"VMware REST API Versioning","text":""},{"location":"api/api-versioning/#typographical-conventions","title":"Typographical conventions","text":"<p>The text in this document is split into two categories \u2014 normative statements and notes. Normative statements represent requirements towards APIs and Products. Notes aim to clarify the normative statements by presenting examples, background information, opinions of engineers, references to other specifications etc. Normative statements are represented as indented information boxes. Notes use all other formats in the document. Example normative statement:</p> <p>Normative Statement</p> <p>Within normative statements, the conventions of\u00a0RFC 2119\u00a0are used. These define the meaning of MAY, SHOULD, SHOULD NOT, MUST and MUST NOT.</p>"},{"location":"api/api-versioning/#api-specification-version","title":"API Specification Version","text":"<p>The goal of using a standard API Specification Versioning mechanism is providing clear expectations around various types of API contract changes in order to help to maintain interoperability.</p> <p>API Specification SHOULD be versioned following\u00a0Semantic Versioning.\u00a0\u00a0</p> <p>Given a version number\u00a0<code>MAJOR.MINOR.PATCH</code>, increment the:</p> <ol> <li>MAJOR version when you make incompatible API changes,</li> <li>MINOR version when you add functionality in a backwards-compatible manner, and</li> <li>PATCH version\u00a0when you make backwards-compatible bug fixes.</li> </ol> <p>The PATCH version SHOULD NOT be considered by API level integrations and tooling.\u00a0Changes in the API specification that don't change the contract, e.g. fixes or additions in the documentation, SHOULD result in incrementing the PATCH version.\u00a0</p> <p>API Specification version MAY be referred to using a short version representation, omitting the PATCH number, for documentation and compatibility purposes.</p> Version (MAJOR.MINOR.PATCH) Short Version (MAJOR.MINOR) Description 2.3.1 2.3 Version 2.3 GA Release 2.4.0-alpha1 2.4-alpha1 Alpha 1 release of version 2.4 2.4.0-beta 2.4-beta1 Beta release of version 2.4 <p>API Specification version SHOULD be provided as part of the API Specification</p> <p>API Specification represents the contract between the API Provider and API Consumer and is a mechanism for communicating version and contract updates.</p>"},{"location":"api/api-versioning/#vmodl2","title":"VMODL2","text":"<p>For APIs defined using VMODL2 specification API Specification version MUST be provided using the @Component annotation</p> <p>VMODL2 API Specification version SHOULD be provided as part of the Component declaration following MAJOR.MINOR format.</p> <pre><code>/**\n * The {@name com.vmware.vcenter} {@term package} provides {@term services} for\n * managing VMware vSphere environments.\n */\n@Component(versions= {\"1.0\", \"1.5\", \"2.0\"})\npackage com.vmware.vcenter;\n\nimport vmodl.lang.Component;\n</code></pre> <p>https://wiki.eng.vmware.com/VAPI/Specs/VMODL2/ApiLifecycle#Component_version_definitions</p>"},{"location":"api/api-versioning/#openapi-specification-20-swagger-20","title":"OpenAPI Specification 2.0 (Swagger 2.0)","text":"<pre><code>---\nswagger: \"2.0\"\ninfo:\n  description: \"This is a sample server Petstore server.\"\n  title: \"Swagger Petstore\"\n  version: \"1.0.0\"\n</code></pre> <p>OpenAPI 2.0 API specification version MUST be provided using the\u00a0Info\u2192version\u00a0property following MAJOR.MINOR.PATCH or MAJOR.MINOR format.</p>"},{"location":"api/api-versioning/#openapi-specification-3x","title":"OpenAPI Specification 3.x","text":"<p>OpenAPI 3.x API specification version MUST be provided using the\u00a0Info\u2192version\u00a0property\u00a0following MAJOR.MINOR.PATCH or MAJOR.MINOR format.</p> <pre><code>openapi: 3.0.1\ninfo:\n  title: Swagger Petstore\n  description: 'This is a sample server Petstore server.'\n  version: 1.0.0\n</code></pre>"},{"location":"api/api-versioning/#other-interface-definition-languagesidls","title":"Other Interface Definition Languages(IDLs)","text":"<p>In order to help to move the standardization effort forward, when attempting to use an IDL not listed above, API Providers are expected to share their intention with the API Standards group and propose to include the IDL in the Standard. In the scope of the API Versioning Standard, that would result in including an API Specification versioning recommendation for the IDL. If a versioning mechanism is not provided by the IDL, it can be proposed by the API Provider as part of the nomination for standardization.</p>"},{"location":"api/api-versioning/#api-implementation-version-alignment","title":"API Implementation version alignment","text":"<p>To achieve closer alignment and consistent experience, it is recommended to use Semantic Versioning for\u00a0API implementation where possible.</p> <p>If both API Specification and API Implementation are versioned using Semantic Versioning, their versions should not be tightly coupled. For example, API Implementations may have multiple patch versions without affecting the API Specification version.\u00a0</p> <p>However, incrementing the MINOR version of the API Implementation should result in propagating the increment to the API Specification version while exposing the change.</p> <p>A single API Specification may include multiple API implementations, spanning multiple implementing services. The API Specification provides an abstraction for consumers and hides the implementation details.\u00a0\u00a0</p> API Specification API implementation API Specification API implementation 2.1.3 Foo API 1.2.3 Bar API 2.4.1 Baz API 2.3.4 <p>The API Specification MINOR version MUST be incremented if any of underlying implementations introduce a new, non-breaking functionality exposed through the API.</p> <p>The API Specification MAJOR version MUST be incremented if any of underlying implementations introduce a breaking change.</p>"},{"location":"api/api-versioning/#sdk-versioning","title":"SDK Versioning","text":"<p>SDKs typically include multiple versioned components. Aligning component versions with the SDK version is not always possible.\u00a0</p> <p>SDK deliverables SHOULD be versioned using Semantic Versioning, where major versions are updated if a major version of an API covered by the SDK is incremented. Otherwise, the minor version should be incremented for feature releases.</p> <p>The MAJOR version of the SDK increment should be applied when any of the included APIs undergo a major release. Alternatively, if an SDK release only includes new features, documentation updates, sample updates or fixes, should typically increment the minor version.\u00a0</p> <p>Note that the addition of a new API or a component into the SDK qualifies as a major update. Major releases can also be justified in case of a major rework of the SDK content or overall structure.</p> <p>SDK versions SHOULD be independent of product versions.\u00a0</p> <p>SDK deliverables typically cover multiple products each having independent versions and release schedules. Hence, the SDK versions do not have to be aligned to product versions, nor should major increments be triggered by a major release of a product. On the contrary, major releases of APIs covered by the SDK should trigger SDK major release increments.</p> <p>SDK deliverables MUST explicitly list the most recent product versions tested against and clarify compatibility expectations.\u00a0</p> <p>Developers should be able to easily pick a version of the SDK that is the latest compatible with the set of products they are interested in working with.\u00a0</p>"},{"location":"api/api-versioning/#api-changes-and-product-releases","title":"API Changes and Product Releases","text":"<p>To maintain clear expectations only certain types of API changes are allowed per product release type. Release types outlined below are provided for semantical alignment purposes and may not match exactly the terminology defined by specific products. If such an alignment is not possible, product teams should be reaching out to the API Standards team with the details outlining the mismatch.\u00a0</p>"},{"location":"api/api-versioning/#major-releases","title":"Major releases","text":"<p>Major releases MAY introduce new APIs, as well as changes to existing APIs.\u00a0</p> <p>Breaking API changes introduced in a major release MUST follow the Evolution and Deprecation guidelines.\u00a0</p> <p>There are no constraints on the type of API changes for major releases. So as long as API changes follow API evolution and deprecation guidelines, any change is allowed.</p>"},{"location":"api/api-versioning/#minor-releases","title":"Minor releases","text":"<p>Minor releases MAY introduce new APIs and backward-compatible changes to existing APIs.\u00a0</p> <p>Minor releases may introduce new APIs, as well as update existing APIs while maintaining backward-compatibility. For existing APIs, such changes would be accompanied by MINOR version updates.</p> <p>Minor release MUST NOT introduce breaking API changes.</p> <p>Neither backward-incompatible changes nor API removal is allowed in minor releases.\u00a0</p> <p>Minor releases MAY deprecate existing APIs.\u00a0</p> <p>Deprecation of an API is allowed in minor releases, following the API deprecation guidelines.\u00a0</p> <p>Minor releases MUST NOT remove deprecated APIs.</p> <p>API removal is considered a breaking change and is only allowed in Major releases.\u00a0</p>"},{"location":"api/api-versioning/#patch-releases","title":"Patch releases","text":"<p>Patch releases MUST NOT introduce new APIs.\u00a0</p> <p>New APIs and new features can only be introduced at the Minor release level.</p> <p>Patch releases MAY include PATCH version updates in existing APIs.</p> <p>No new features or breaking changes are allowed in Patch releases. Hence, there may not be MINOR or MAJOR version changes.</p> <p>Patch releases MUST NOT deprecate existing APIs.</p> <p>APIs can only be deprecated in Minor or Major releases.</p>"},{"location":"api/api-versioning/#rest-api-versioning","title":"REST API Versioning","text":"<p>REST API Versioning is covered in the REST Standard:\u00a0https://gitlab.eng.vmware.com/core-build/rest-specification/blob/v2.0/REST-specification.md</p>"},{"location":"api/appvolumes/","title":"AppVolumes API","text":""},{"location":"api/horizon-server/","title":"Horizon Server API","text":""},{"location":"api/ws1-identity/","title":"Workspace ONE Intelligence API","text":""},{"location":"api/ws1-notifications/","title":"Workspace ONE Notification Service API","text":""},{"location":"architecture/","title":"Workspace ONE Architecture","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque nec maximus ex. Sed consequat, nulla quis malesuada dapibus, elit metus vehicula erat, ut egestas tellus eros at risus. In hac habitasse platea dictumst. Phasellus id lacus pulvinar erat consequat pretium. Morbi malesuada arcu mauris Nam vel justo sem. Nam placerat purus non varius luctus. Integer pretium leo in sem rhoncus, quis gravida orci mollis. Proin id aliquam est. Vivamus in nunc ac metus tristique pellentesque. Suspendisse viverra urna in accumsan aliquet.</p> <p>Donec volutpat, elit ac volutpat laoreet, turpis dolor semper nibh, et dictum massa ex pulvinar elit. Curabitur commodo sit amet dolor sed mattis. Etiam tempor odio eu nisi gravida cursus. Maecenas ante enim, fermentum sit amet molestie nec, mollis ac libero. Vivamus sagittis suscipit eros ut luctus.</p> <p>Nunc vehicula sagittis condimentum. Cras facilisis bibendum lorem et feugiat. In auctor accumsan ligula, at consectetur erat commodo quis. Morbi ac nunc pharetra, pellentesque risus in, consectetur urna. Nulla id enim facilisis arcu tincidunt pulvinar. Vestibulum laoreet risus scelerisque porta congue. In velit purus, dictum quis neque nec, molestie viverra risus. Nam pellentesque tellus id elit ultricies, vel finibus erat cursus.</p>"},{"location":"architecture/access/","title":"Workspace ONE Access Architecture","text":""},{"location":"architecture/access/#cloud-based-architecture","title":"Cloud-Based Architecture","text":"<p>In a cloud-based implementation, the Workspace ONE Access Connector service synchronizes user accounts from Active Directory to the Workspace ONE Access tenant service. Applications can then be accessed from a cloud-based entry point.</p> <p></p> <p>The main components of a cloud-based Workspace ONE Access implementation are described in the following table.</p> <p>Table 2: Workspace ONE Access Components</p> Component Description Workspace ONE Access tenant Hosted in the cloud and runs the main Workspace ONE Access service. Workspace ONE Access Connector Responsible for directory synchronization and handles some of the authentication methods between on-premises resources such as Active Directory, VMware Horizon, Citrix, and the Workspace ONE Access service."},{"location":"architecture/access/#on-premises-architecture","title":"On-Premises Architecture","text":"<p>For the on-premises deployment, we use the Linux-based virtual appliance version of the Workspace ONE Access service. This appliance is often deployed to the DMZ. There are use cases for LAN deployment, but they are rare, and we focus on the most common deployment method in this guide.</p> <p>Syncing resources such as Active Directory, Citrix apps and desktops, and Horizon desktops and published apps is done by using a separate Workspace ONE Access Connector. The Workspace ONE Access Connector runs inside the LAN using an outbound-only connection to the Workspace ONE Access service, meaning the connector receives no incoming connections from the DMZ or from the Internet.</p> <p> The implementation is separated into three main components.</p> Component Description Workspace ONE Access appliance Runs the main Workspace ONE Access Service.The Workspace ONE Access Service is a virtual appliance (OVA file) that you deploy in a VMware vSphere\u00ae environment. Workspace ONE Access Connector Performs directory synchronization and authentication between on-premises resources such as Active Directory, VMware Horizon, and the Workspace ONE Access service.You deploy the connector by running a Windows-based installer. Database Stores and organizes server-state data and user account data. <p>Learn more about how Workspace ONE Access works, what to consider, and how to design deployments by reviewing the Workspace ONE Access Architecture.</p>"},{"location":"architecture/appvolumes/","title":"Workspace ONE AppVolumes Architecture","text":"<p>The core components of App Volumes include the App Volumes Agent running in the virtual machine and communicating with the App Volumes Managers. Application package assignments are processed and attached to the virtual machine either at logon, or on-demand, when the user launches the application. If the user has a writable volume assigned to them, that is attached to the virtual machine as well.</p> <p></p> <p>The key components of App Volumes are:</p> <ul> <li>App Volumes Manager \u2013 Acts as the broker for App Volumes Agents for the assignment of Packages and Writable Volumes. Multiple App Volumes Managers are deployed behind a third-party load balancer.</li> <li>App Volumes Agent \u2013 Installed on the guest OS of the target VM or system. This agent communicates with the App Volumes Managers. It adds an abstraction layer to the file systems and registry.</li> <li>Application -  Logical component containing one or more packages. Used to assign AD users and groups to packages.</li> <li>Package \u2013 A particular version of an application. A package is stored in a read-only volume containing the captured programs. The package virtual disk file is attached to deliver the applications to VDI or RDSH machines. One or more packages may be assigned per user or machine.</li> <li>Writable Volumes \u2013 Read-write volume that persists changes written in the session, including user-installed applications and user profile. One Writable Volume per user.</li> </ul> <p>Learn more about how App Volumes works, what to consider, and how to design deployments by reviewing the App Volumes Reference Architecture.</p>"},{"location":"architecture/assist/","title":"Workspace ONE Assist Architecture","text":"<p>Workspace ONE Assist Architecture</p>"},{"location":"architecture/deem/","title":"Dynamic Environment Manager Architecture","text":"<p>A robust solution for profile management through dynamic policy configuration that combines the ease of managing application and persona settings with providing end users a personalized desktop experience across any virtual, physical, and cloud-based Windows desktop environment.</p> <p>Dynamic Environment Manager uses file shares to distribute policies, personalization,  and to store user profile information. This makes it simple to deploy, and light on infrastructure requirements.</p> <p></p> <p>Learn more about how Dynamic Environment Manager works, what to consider, and how to design deployments by reviewing the Dynamic Environment Manager Reference Architecture.</p>"},{"location":"architecture/horizon/","title":"Workspace ONE and Horizon Architecture","text":"<p>VMware Workspace ONE and Horizon Reference Architecture Overview</p>"},{"location":"architecture/intelligence/","title":"Workspace ONE Intelligence Architecture","text":"<p>Workspace ONE Intelligence Architecture</p>"},{"location":"architecture/uem/","title":"Workspace ONE UEM Architecture","text":"<p>Workspace ONE UEM Architecture</p>"},{"location":"architecture/workspaceone/","title":"Workspace ONE Architecture","text":"<p>VMware Workspace ONE and Horizon Reference Architecture Overview</p>"},{"location":"powercli/","title":"EUC PowerCLI Modules","text":""},{"location":"powercli/#vmware-powercli","title":"VMware PowerCLI","text":"<p>PowerCLI is the tool millions of customers around the world use to manage and automate their VMware environments. Discover what you can achieve with PowerCLI today.</p>"},{"location":"powercli/#powercli-powershell-modules","title":"PowerCLI / PowerShell Modules","text":"<p>PowerShell Module for VMware Validated Solutions </p> <p>PowerShell Module for VMware Cloud Foundation  </p> <p>PowerShell Module for VMware Cloud Foundation Reporting </p> <p>PowerShell Module for VMware Cloud Foundation Password Management </p> <p>PowerShell Module for VMware Cloud Foundation Certificate Management </p>"},{"location":"products/","title":"Workspace ONE Products","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque nec maximus ex. Sed consequat, nulla quis malesuada dapibus, elit metus vehicula erat, ut egestas tellus eros at risus. In hac habitasse platea dictumst. Phasellus id lacus pulvinar erat consequat pretium. Morbi malesuada arcu mauris Nam vel justo sem. Nam placerat purus non varius luctus. Integer pretium leo in sem rhoncus, quis gravida orci mollis. Proin id aliquam est. Vivamus in nunc ac metus tristique pellentesque. Suspendisse viverra urna in accumsan aliquet.</p> <p>Donec volutpat, elit ac volutpat laoreet, turpis dolor semper nibh, et dictum massa ex pulvinar elit. Curabitur commodo sit amet dolor sed mattis. Etiam tempor odio eu nisi gravida cursus. Maecenas ante enim, fermentum sit amet molestie nec, mollis ac libero. Vivamus sagittis suscipit eros ut luctus.</p> <p>Nunc vehicula sagittis condimentum. Cras facilisis bibendum lorem et feugiat. In auctor accumsan ligula, at consectetur erat commodo quis. Morbi ac nunc pharetra, pellentesque risus in, consectetur urna. Nulla id enim facilisis arcu tincidunt pulvinar. Vestibulum laoreet risus scelerisque porta congue. In velit purus, dictum quis neque nec, molestie viverra risus. Nam pellentesque tellus id elit ultricies, vel finibus erat cursus.</p> <ul> <li> <p></p> <p>Digital workspace platform that enables zero trust</p> <p> Reference</p> </li> <li> <p></p> <p>Multi-platform endpoint and app management</p> <p> Reference</p> </li> <li> <p></p> <p>Focus on your content and generate a responsive and searchable static site</p> <p> Reference</p> </li> <li> <p></p> <p>Focus on your content and generate a responsive and searchable static site</p> <p> Reference</p> </li> <li> <p></p> <p>Employee launching-pad, makes login easy especially for those with bring your own (BYO) devices</p> <p> Reference</p> </li> <li> <p></p> <p>Securely discover, access, and connect to your company\u2019s resources, teams, and workflows</p> <p> Reference</p> </li> <li> <p></p> <p>Remote support for digital employees</p> <p> Reference</p> </li> <li> <p></p> <p>Connect your end users to the applications and desktops they want to access</p> <p> Reference</p> </li> <li> <p></p> <p>Manage time, projects, passwords, to-do lists, and be more productive</p> <p> Reference</p> </li> <li> <p></p> <p>Secure virtual desktop (VDI) and app platform</p> <p> Reference</p> </li> </ul>"},{"location":"samples/","title":"EUC Developer Sample Code","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque nec maximus ex. Sed consequat, nulla quis malesuada dapibus, elit metus vehicula erat, ut egestas tellus eros at risus. In hac habitasse platea dictumst. Phasellus id lacus pulvinar erat consequat pretium. Morbi malesuada arcu mauris Nam vel justo sem. Nam placerat purus non varius luctus. Integer pretium leo in sem rhoncus, quis gravida orci mollis. Proin id aliquam est. Vivamus in nunc ac metus tristique pellentesque. Suspendisse viverra urna in accumsan aliquet.</p> <p>Donec volutpat, elit ac volutpat laoreet, turpis dolor semper nibh, et dictum massa ex pulvinar elit. Curabitur commodo sit amet dolor sed mattis. Etiam tempor odio eu nisi gravida cursus. Maecenas ante enim, fermentum sit amet molestie nec, mollis ac libero. Vivamus sagittis suscipit eros ut luctus.</p> <p>Nunc vehicula sagittis condimentum. Cras facilisis bibendum lorem et feugiat. In auctor accumsan ligula, at consectetur erat commodo quis. Morbi ac nunc pharetra, pellentesque risus in, consectetur urna. Nulla id enim facilisis arcu tincidunt pulvinar. Vestibulum laoreet risus scelerisque porta congue. In velit purus, dictum quis neque nec, molestie viverra risus. Nam pellentesque tellus id elit ultricies, vel finibus erat cursus.</p>"},{"location":"sdk/","title":"EUC Developer SDKs","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque nec maximus ex. Sed consequat, nulla quis malesuada dapibus, elit metus vehicula erat, ut egestas tellus eros at risus. In hac habitasse platea dictumst. Phasellus id lacus pulvinar erat consequat pretium. Morbi malesuada arcu mauris Nam vel justo sem. Nam placerat purus non varius luctus. Integer pretium leo in sem rhoncus, quis gravida orci mollis. Proin id aliquam est. Vivamus in nunc ac metus tristique pellentesque. Suspendisse viverra urna in accumsan aliquet.</p> <p>Donec volutpat, elit ac volutpat laoreet, turpis dolor semper nibh, et dictum massa ex pulvinar elit. Curabitur commodo sit amet dolor sed mattis. Etiam tempor odio eu nisi gravida cursus. Maecenas ante enim, fermentum sit amet molestie nec, mollis ac libero. Vivamus sagittis suscipit eros ut luctus.</p> <p>Nunc vehicula sagittis condimentum. Cras facilisis bibendum lorem et feugiat. In auctor accumsan ligula, at consectetur erat commodo quis. Morbi ac nunc pharetra, pellentesque risus in, consectetur urna. Nulla id enim facilisis arcu tincidunt pulvinar. Vestibulum laoreet risus scelerisque porta congue. In velit purus, dictum quis neque nec, molestie viverra risus. Nam pellentesque tellus id elit ultricies, vel finibus erat cursus.</p>"},{"location":"tools/","title":"EUC Developer Tools","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque nec maximus ex. Sed consequat, nulla quis malesuada dapibus, elit metus vehicula erat, ut egestas tellus eros at risus. In hac habitasse platea dictumst. Phasellus id lacus pulvinar erat consequat pretium. Morbi malesuada arcu mauris Nam vel justo sem. Nam placerat purus non varius luctus. Integer pretium leo in sem rhoncus, quis gravida orci mollis. Proin id aliquam est. Vivamus in nunc ac metus tristique pellentesque. Suspendisse viverra urna in accumsan aliquet.</p> <p>Donec volutpat, elit ac volutpat laoreet, turpis dolor semper nibh, et dictum massa ex pulvinar elit. Curabitur commodo sit amet dolor sed mattis. Etiam tempor odio eu nisi gravida cursus. Maecenas ante enim, fermentum sit amet molestie nec, mollis ac libero. Vivamus sagittis suscipit eros ut luctus.</p> <p>Nunc vehicula sagittis condimentum. Cras facilisis bibendum lorem et feugiat. In auctor accumsan ligula, at consectetur erat commodo quis. Morbi ac nunc pharetra, pellentesque risus in, consectetur urna. Nulla id enim facilisis arcu tincidunt pulvinar. Vestibulum laoreet risus scelerisque porta congue. In velit purus, dictum quis neque nec, molestie viverra risus. Nam pellentesque tellus id elit ultricies, vel finibus erat cursus.</p>"}]}